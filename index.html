<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>F1 Snake with Leaderboard + Chat</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; background: #111;
    font-family: sans-serif;
    touch-action: none;
  }
  #ui {
    position: absolute; top: 12px; left: 12px; color: #fff; z-index: 30;
    background: rgba(0,0,0,0.25); padding: 8px 12px; border-radius: 8px;
    user-select: none;
    max-width: 220px;
  }
  #leaderboard {
    margin-top: 10px;
    font-size: 14px;
    max-height: 250px;
    overflow-y: auto;
  }
  #chat {
    position: absolute;
    top: 12px; left: 250px; bottom: 12px;
    width: 280px;
    background: rgba(0,0,0,0.7);
    color: white;
    font-size: 14px;
    display: flex;
    flex-direction: column;
    border-radius: 8px;
    user-select: text;
    z-index: 20;
  }
  #chatMessages {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    line-height: 1.3;
  }
  #chatInput {
    border: none;
    padding: 10px;
    font-size: 14px;
    outline: none;
    border-top: 1px solid #333;
    background: #222;
    color: white;
  }
  #chatInput::placeholder {
    color: #888;
  }
  #namePromptOverlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 50;
  }
  #namePromptBox {
    background: #222;
    padding: 20px 30px;
    border-radius: 10px;
    color: white;
    font-size: 18px;
    max-width: 90vw;
    text-align: center;
  }
  #nameInput {
    width: 100%;
    padding: 8px 10px;
    font-size: 16px;
    margin-top: 12px;
    border-radius: 6px;
    border: none;
    outline: none;
  }
  #startButton {
    margin-top: 15px;
    padding: 10px 18px;
    font-size: 16px;
    background: #0af;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }
  #startButton:hover {
    background: #08c;
  }
</style>

<!-- Firebase App (the core Firebase SDK) -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<!-- Firestore SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

</head>
<body>
<div id="ui">
  Score: <span id="score">0</span>
  <div id="leaderboard">Loading leaderboard...</div>
  <br />
  Controls: A/D or ‚óÄÔ∏è/‚ñ∂Ô∏è or touch left/right half, double tap or two-finger tap to boost
</div>

<div id="chat" style="display:none;">
  <div id="chatMessages"></div>
  <input id="chatInput" placeholder="Type message and press Enter" autocomplete="off" />
</div>

<div id="namePromptOverlay">
  <div id="namePromptBox">
    Enter your player name:<br/>
    <input id="nameInput" maxlength="20" placeholder="Player name" autocomplete="off" />
    <button id="startButton">Start Game</button>
  </div>
</div>

<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script>
(() => {
  // --- Firebase setup ---

  // REPLACE these with your Firebase project config values
  const firebaseConfig = {
    apiKey: "AIzaSyC5seSlgxk4mCRn4HKet4rHlzhQVVBxc-8",
    authDomain: "f1-snake.firebaseapp.com",
    projectId: "f1-snake",
    storageBucket: "f1-snake.firebasestorage.app",
    messagingSenderId: "575341092161",
    appId: "1:575341092161:web:b9050e1df88c9e36de95c0"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // --- Leaderboard functions ---
  async function submitScore(name, score) {
    try {
      const snapshot = await db.collection('leaderboard')
        .where('name', '==', name)
        .limit(1)
        .get();
      if (!snapshot.empty) {
        const doc = snapshot.docs[0];
        const existingScore = doc.data().score || 0;
        if (score > existingScore) {
          await doc.ref.update({score, timestamp: firebase.firestore.FieldValue.serverTimestamp()});
        }
      } else {
        await db.collection('leaderboard').add({
          name, score,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    } catch(e) {
      console.error('Error saving score:', e);
    }
  }
  async function getTopScores(limit = 10) {
    try {
      const snapshot = await db.collection('leaderboard')
        .orderBy('score', 'desc')
        .limit(limit)
        .get();
      return snapshot.docs.map(doc => doc.data());
    } catch(e) {
      console.error('Error fetching leaderboard:', e);
      return [];
    }
  }

  // --- Leaderboard realtime update ---
  const leaderboardEl = document.getElementById('leaderboard');
  function startLeaderboardListener() {
    db.collection('leaderboard')
      .orderBy('score', 'desc')
      .limit(10)
      .onSnapshot(snapshot => {
        let html = '<strong>üèÜ Leaderboard üèÜ</strong><br>';
        snapshot.docs.forEach((doc, i) => {
          const d = doc.data();
          html += `${i+1}. ${d.name}: ${d.score}<br>`;
        });
        leaderboardEl.innerHTML = html;
      });
  }

  // --- Chat setup ---
  const CHAT_MAX_MESSAGES = 50;
  let playerName = "";
  const chatMessagesEl = document.getElementById('chatMessages');
  const chatInputEl = document.getElementById('chatInput');
  const chatContainerEl = document.getElementById('chat');

  let chatUnsubscribe = null;
  function startChatListener() {
    chatUnsubscribe = db.collection('chat')
      .orderBy('timestamp', 'desc')
      .limit(CHAT_MAX_MESSAGES)
      .onSnapshot(snapshot => {
        const msgs = [];
        snapshot.docs.forEach(doc => {
          msgs.push(doc.data());
        });
        msgs.reverse();
        chatMessagesEl.innerHTML = "";
        msgs.forEach(m => {
          const div = document.createElement('div');
          const timeStr = m.timestamp ? new Date(m.timestamp.seconds * 1000).toLocaleTimeString() : '';
          div.textContent = `[${timeStr}] ${m.name}: ${m.message}`;
          chatMessagesEl.appendChild(div);
        });
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      });
  }

  async function sendMessage(text) {
    if (!text.trim()) return;
    try {
      await db.collection('chat').add({
        name: playerName,
        message: text.trim(),
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      });
      const snapshot = await db.collection('chat')
        .orderBy('timestamp', 'asc')
        .get();
      if (snapshot.size > CHAT_MAX_MESSAGES) {
        const toDelete = snapshot.docs.slice(0, snapshot.size - CHAT_MAX_MESSAGES);
        const batch = db.batch();
        toDelete.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
      }
    } catch(e) {
      console.error('Error sending chat message:', e);
    }
  }

  // --- Game code ---
  const ARENA_RADIUS = 120;
  const SEGMENT_DISTANCE = 6;
  const BOOST_MULTIPLIER = 2.4;
  const BOOST_DURATION = 2000;
  const BOOST_COOLDOWN = 4000;
  const OBSTACLE_COUNT = 10;

  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x111111, 0.0025);
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.5, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(50, 100, 50);
  scene.add(dirLight);

  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(ARENA_RADIUS, 64),
    new THREE.MeshStandardMaterial({color:0x0d3b66})
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  function makeCar(color=0xff2d55) {
    const group = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(3.4, 1.2, 7.6),
      new THREE.MeshStandardMaterial({color})
    );
    body.position.y = 0.6;
    group.add(body);
    return group;
  }

  const cars = [];
  cars.push({
    position: new THREE.Vector3(0, 0, 0),
    rotationY: 0,
    mesh: makeCar(0xff2d55),
    boost: { active: false, cooldown: 0, timer: 0 }
  });
  scene.add(cars[0].mesh);
  cars[0].mesh.position.set(0, 0, 0);

  function addFollower() {
    const leader = cars[cars.length - 1];
    const follower = {
      position: new THREE.Vector3().copy(leader.position),
      rotationY: leader.rotationY,
      mesh: makeCar(0xff8a00),
    };
    const backOffset = new THREE.Vector3(0, 0, -SEGMENT_DISTANCE).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotationY);
    follower.position.add(backOffset);
    scene.add(follower.mesh);
    cars.push(follower);
  }

  const pickups = [];
  function spawnPickup() {
    const r = THREE.MathUtils.randFloat(10, ARENA_RADIUS - 10);
    const a = THREE.MathUtils.randFloat(0, Math.PI * 2);
    const x = Math.cos(a) * r, z = Math.sin(a) * r;
    const coneGeo = new THREE.ConeGeometry(1.2, 2.2, 10);
    const coneMat = new THREE.MeshStandardMaterial({ color: 0x00ffae });
    const mesh = new THREE.Mesh(coneGeo, coneMat);
    mesh.position.set(x, 1.1, z);
    mesh.rotation.x = Math.PI;
    scene.add(mesh);
    pickups.push(mesh);
  }
  for (let i = 0; i < 6; i++) spawnPickup();

  const obstacles = [];
  function spawnObstacles() {
    for(let i=0; i < OBSTACLE_COUNT; i++) {
      const r = THREE.MathUtils.randFloat(15, ARENA_RADIUS - 15);
      const a = THREE.MathUtils.randFloat(0, Math.PI * 2);
      const x = Math.cos(a) * r, z = Math.sin(a) * r;
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(6, 6, 6),
        new THREE.MeshStandardMaterial({color: 0xaa0000})
      );
      mesh.position.set(x, 3, z);
      scene.add(mesh);
      obstacles.push(mesh);
    }
  }
  spawnObstacles();

  const keys = {};
  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  let touchLeft = false;
  let touchRight = false;
  let lastTap = 0;

  function handleTouchStart(e) {
    e.preventDefault();
    if (e.touches.length === 1) {
      const touchX = e.touches[0].clientX;
      if (touchX < window.innerWidth / 2) {
        touchLeft = true;
      } else {
        touchRight = true;
      }
    } else if (e.touches.length === 2) {
      if (canBoost(cars[0])) {
        startBoost(cars[0]);
      }
    }
  }
  function handleTouchEnd(e) {
    e.preventDefault();
    touchLeft = false;
    touchRight = false;
  }
  function handleTap(e) {
    const now = Date.now();
    if (now - lastTap < 300) {
      if (canBoost(cars[0])) startBoost(cars[0]);
    }
    lastTap = now;
  }
  window.addEventListener('touchstart', handleTouchStart, { passive: false });
  window.addEventListener('touchend', handleTouchEnd, { passive: false });
  window.addEventListener('touchcancel', handleTouchEnd, { passive: false });
  window.addEventListener('click', handleTap);

  let score = 0;
  const scoreEl = document.getElementById('score');
  let alive = true;
  let leaderboardSubmitted = false;

  function canBoost(car) {
    const now = performance.now();
    if (car.boost.cooldown && now < car.boost.cooldown) return false;
    return true;
  }
  function startBoost(car) {
    const now = performance.now();
    car.boost.active = true;
    car.boost.timer = now + BOOST_DURATION;
    car.boost.cooldown = now + BOOST_DURATION + BOOST_COOLDOWN;
  }
  function updateBoost(car) {
    const now = performance.now();
    if (car.boost.active && now > car.boost.timer) {
      car.boost.active = false;
    }
  }

  async function gameOver() {
    if (leaderboardSubmitted) return;
    leaderboardSubmitted = true;

    let playerNamePrompt = prompt("Game Over! Enter your name for leaderboard:", playerName || "Player");
    if (playerNamePrompt) {
      playerNamePrompt = playerNamePrompt.trim().substring(0, 20) || "Player";
      playerName = playerNamePrompt; // update name to latest
      await submitScore(playerName, score);
    }
  }

  // --- Player name prompt & start game ---
  const namePromptOverlay = document.getElementById('namePromptOverlay');
  const nameInput = document.getElementById('nameInput');
  const startButton = document.getElementById('startButton');
  const chatInput = document.getElementById('chatInput');
  const chatDiv = document.getElementById('chat');

  startButton.onclick = () => {
    const val = nameInput.value.trim().substring(0, 20);
    if (val.length === 0) {
      alert("Please enter a player name.");
      return;
    }
    playerName = val;
    namePromptOverlay.style.display = 'none';
    chatDiv.style.display = 'flex';
    animate();
    startChatListener();
    startLeaderboardListener();
  };

  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') startButton.click();
  });

  chatInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      sendMessage(chatInput.value);
      chatInput.value = '';
    }
  });

  // --- Animation Loop ---
  let lastTime = performance.now();

  function animate() {
    if (alive) requestAnimationFrame(animate);
    const now = performance.now();
    const deltaRaw = (now - lastTime) / 1000;
    const delta = Math.min(deltaRaw, 0.05);
    lastTime = now;

    if (!alive) {
      renderer.render(scene, camera);
      return;
    }
    const player = cars[0];

    const BASE_SPEED = isMobile ? 7 : 15;
    const ROTATION_SPEED = isMobile ? 2.5 : 3.5;

    if (keys['a'] || keys['arrowleft'] || touchLeft) player.rotationY += ROTATION_SPEED * delta;
    if (keys['d'] || keys['arrowright'] || touchRight) player.rotationY -= ROTATION_SPEED * delta;

    if ((keys[' '] && canBoost(player)) || player.boost.active) {
      if (keys[' '] && canBoost(player)) startBoost(player);
    }
    updateBoost(player);

    const speed = BASE_SPEED * (player.boost.active ? BOOST_MULTIPLIER : 1);

    const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotationY);
    player.position.add(forward.multiplyScalar(speed * delta));

    for (let i = 1; i < cars.length; i++) {
      const leader = cars[i - 1];
      const follower = cars[i];
      const dir = new THREE.Vector3().subVectors(leader.position, follower.position);
      const dist = dir.length();
      if (dist > SEGMENT_DISTANCE) {
        dir.normalize();
        follower.position.add(dir.multiplyScalar(Math.min(dist - SEGMENT_DISTANCE, speed * delta * 1.5)));
      }
      const targetRotation = Math.atan2(dir.x, dir.z);
      follower.rotationY += (targetRotation - follower.rotationY) * 0.15;
    }

    for (let i = 0; i < cars.length; i++) {
      const c = cars[i];
      c.mesh.position.copy(c.position).setY(0.6);
      c.mesh.rotation.y = c.rotationY;
    }

    for (let i = pickups.length - 1; i >= 0; i--) {
      if (pickups[i].position.distanceTo(player.position) < 3) {
        scene.remove(pickups[i]);
        pickups.splice(i, 1);
        score++;
        scoreEl.textContent = score;
        addFollower();
        spawnPickup();
      }
    }

    for(const obs of obstacles){
      if(obs.position.distanceTo(player.position) < 4.5){
        alive = false;
        scoreEl.textContent = `Crashed into obstacle! Final Score: ${score}`;
        gameOver();
      }
    }

    if (player.position.length() > ARENA_RADIUS) {
      alive = false;
      scoreEl.textContent = `Hit the wall! Final Score: ${score}`;
      gameOver();
    }

    const camOffset = new THREE.Vector3(0, 15, -30).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotationY);
    camera.position.copy(player.position.clone().add(camOffset));
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
})();
</script>
</body>
</html>
