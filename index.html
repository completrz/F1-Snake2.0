<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>F1 Snake ‚Äî Leaderboard + Chat</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  :root{
    --glass: rgba(0,0,0,0.35);
    --panel: rgba(0,0,0,0.75);
    --accent: #00e5ff;
    --danger: #ff3b30;
  }
  html, body {
    margin: 0; height: 100%; overflow: hidden; background: #0b0f14;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: #fff;
    touch-action: none;
  }

  /* HUD (left) */
  #hud {
    position: absolute; top: 14px; left: 14px; z-index: 30;
    background: var(--glass); padding: 10px 12px; border-radius: 12px;
    backdrop-filter: blur(6px);
    width: 260px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }
  #scoreRow { font-weight: 700; font-size: 18px; }
  #hint   { margin-top: 6px; font-size: 12px; opacity: .85; line-height: 1.35; }

  /* Chat (square, under instructions, left) */
  #chat {
    margin-top: 10px;
    width: 260px; height: 260px;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    display: none;            /* shown after name entered */
    flex-direction: column;
    overflow: hidden;
  }
  #chatHeader{
    padding: 8px 10px; font-size: 12px; letter-spacing:.2px; opacity:.9;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  #chatMessages {
    flex: 1; overflow-y: auto; padding: 8px 10px; line-height: 1.35; font-size: 13px;
  }
  #chatInput {
    border: none; outline: none; padding: 10px;
    background: #141920; color: #fff; font-size: 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
  }
  #chatInput::placeholder{ color:#8aa0b4; }

  /* Leaderboard (top-right, ‚Äúnice‚Äù card) */
  #leaderboard {
    position: absolute; top: 14px; right: 14px; z-index: 30;
    width: 280px; max-height: 340px; overflow-y: auto;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 14px; box-shadow: 0 6px 22px rgba(0,0,0,0.45);
    backdrop-filter: blur(6px);
  }
  #lbHeader{
    padding: 10px 14px; border-bottom: 1px solid rgba(255,255,255,0.08);
    display:flex; align-items:center; gap:8px;
  }
  #lbHeader .dot{ width:8px; height:8px; border-radius:50%; background: var(--accent); box-shadow:0 0 10px var(--accent); }
  #lbHeader h3{ margin:0; font-size: 14px; letter-spacing:.3px; font-weight: 700; }
  #lbList{ list-style:none; margin:0; padding: 8px 10px 12px 10px; }
  #lbList li{
    display:flex; justify-content: space-between; align-items:center;
    padding: 8px 8px; margin: 4px 0;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px; font-size: 14px;
  }
  #lbList li .rank{
    width: 22px; height: 22px; border-radius: 6px; display:flex; align-items:center; justify-content:center;
    background: rgba(255,255,255,0.08); font-size: 12px; margin-right: 8px;
  }
  #lbList li .name{ flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  #lbList li .score{ font-weight: 700; color: #b7f; }

  /* Overlays (start/restart, with prefilled name) */
  .overlay {
    position: fixed; inset: 0; display: none; place-items: center; z-index: 50;
    background: radial-gradient(60% 60% at 50% 50%, rgba(0,229,255,0.08), rgba(0,0,0,0.9));
    animation: fadeIn .25s ease-out both;
  }
  @keyframes fadeIn { from{opacity:0} to{opacity:1} }
  .panel {
    width: min(560px, 92vw);
    background: rgba(10,14,20,.85);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    padding: 22px 22px 18px;
    text-align: center;
    backdrop-filter: blur(10px);
  }
  .title {
    font-weight: 800; font-size: 28px; letter-spacing:.3px; margin: 4px 0 6px;
  }
  .subtitle { opacity:.85; font-size: 14px; margin-bottom: 14px; }
  .inputRow { display:flex; gap:10px; justify-content:center; margin-top: 8px; }
  .textInput {
    width: 260px; padding: 10px 12px; border-radius: 10px; border:1px solid rgba(255,255,255,.12);
    outline:none; background:#0f1620; color:#fff; font-size:15px;
  }
  .btn {
    padding: 10px 16px; border-radius: 10px; border: none; cursor: pointer;
    background: linear-gradient(90deg, #00c6ff, #0072ff); color:#001318; font-weight: 800;
    text-transform: uppercase; letter-spacing:.4px;
    box-shadow: 0 10px 24px rgba(0,114,255,.35);
  }
  .btn:hover{ filter: brightness(1.07); }
  .small { font-size:12px; opacity:.8; margin-top:10px; }

  /* Final score badge on restart screen */
  .scoreBadge{
    display:inline-block; padding: 6px 10px; border-radius: 999px;
    background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12);
    margin-bottom: 8px; font-weight:700;
  }
</style>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
</head>
<body>

<!-- HUD (score + instructions + chat square on the left) -->
<div id="hud">
  <div id="scoreRow">Score: <span id="score">0</span></div>
  <div id="hint">Controls: A/D or ‚óÄÔ∏è/‚ñ∂Ô∏è ‚Ä¢ Touch left/right ‚Ä¢ Double-tap/2-finger tap = Boost</div>

  <div id="chat">
    <div id="chatHeader">üí¨ Global Chat</div>
    <div id="chatMessages"></div>
    <input id="chatInput" placeholder="Type & press Enter" autocomplete="off" />
  </div>
</div>

<!-- Leaderboard (top-right) -->
<div id="leaderboard">
  <div id="lbHeader"><span class="dot"></span><h3>Top 10 ‚Äî Global Leaderboard</h3></div>
  <ul id="lbList"><li><span class="rank">‚Äì</span><span class="name">Loading‚Ä¶</span><span class="score">‚Äì</span></li></ul>
</div>

<!-- Start overlay -->
<div id="startOverlay" class="overlay" style="display:grid;">
  <div class="panel">
    <div class="title">F1 Snake</div>
    <div class="subtitle">Collect green cones to grow your train. Dodge red cubes. Boost wisely!</div>
    <div class="inputRow">
      <input id="nameInput" class="textInput" maxlength="20" placeholder="Player name" />
      <button id="startBtn" class="btn">Start</button>
    </div>
    <div class="small">Tip: Your last name will be remembered.</div>
  </div>
</div>

<!-- Restart overlay -->
<div id="restartOverlay" class="overlay">
  <div class="panel">
    <div class="title">Game Over</div>
    <div class="scoreBadge">Final Score: <span id="finalScore">0</span></div>
    <div class="inputRow">
      <input id="restartNameInput" class="textInput" maxlength="20" placeholder="Player name" />
      <button id="restartBtn" class="btn">Restart</button>
    </div>
    <div class="small">Change your name or keep it the same.</div>
  </div>
</div>

<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script>
(() => {
  /* =========================
     Firebase (Firestore)
  ========================== */
  const firebaseConfig = {
    apiKey: "AIzaSyC5seSlgxk4mCRn4HKet4rHlzhQVVBxc-8",
    authDomain: "f1-snake.firebaseapp.com",
    projectId: "f1-snake",
    storageBucket: "f1-snake.firebasestorage.app",
    messagingSenderId: "575341092161",
    appId: "1:575341092161:web:b9050e1df88c9e36de95c0"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  /* =========================
     DOM refs
  ========================== */
  const startOverlay = document.getElementById('startOverlay');
  const restartOverlay = document.getElementById('restartOverlay');
  const nameInput = document.getElementById('nameInput');
  const startBtn = document.getElementById('startBtn');
  const restartNameInput = document.getElementById('restartNameInput');
  const restartBtn = document.getElementById('restartBtn');
  const scoreEl = document.getElementById('score');

  const chatBox = document.getElementById('chat');
  const chatMessagesEl = document.getElementById('chatMessages');
  const chatInputEl = document.getElementById('chatInput');

  const lbList = document.getElementById('lbList');

  /* =========================
     Player / state
  ========================== */
  let playerName = localStorage.getItem('f1snake_name') || '';
  if (playerName) nameInput.value = playerName;

  let alive = false;
  let score = 0;
  let leaderboardSubmitted = false;

  /* =========================
     Leaderboard (pretty, top-right)
  ========================== */
  function startLeaderboardListener(){
    db.collection('leaderboard').orderBy('score','desc').limit(10).onSnapshot(snap=>{
      lbList.innerHTML = '';
      let rank = 1;
      snap.forEach(doc=>{
        const d = doc.data();
        const li = document.createElement('li');
        li.innerHTML = `<span class="rank">${rank}</span>
                        <span class="name">${(d.name||'Player')}</span>
                        <span class="score">${d.score||0}</span>`;
        lbList.appendChild(li);
        rank++;
      });
      if (rank === 1){
        const li = document.createElement('li');
        li.innerHTML = `<span class="rank">‚Äì</span>
                        <span class="name">No scores yet</span>
                        <span class="score">‚Äì</span>`;
        lbList.appendChild(li);
      }
    });
  }
  startLeaderboardListener();

  async function submitScore(name, scoreVal){
    try{
      const q = await db.collection('leaderboard').where('name','==',name).limit(1).get();
      if (!q.empty){
        const docRef = q.docs[0].ref;
        const prev = q.docs[0].data().score || 0;
        if (scoreVal > prev){
          await docRef.update({score: scoreVal, timestamp: firebase.firestore.FieldValue.serverTimestamp()});
        }
      } else {
        await db.collection('leaderboard').add({
          name, score: scoreVal, timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    }catch(e){ console.error(e); }
  }

  /* =========================
     Chat (left square, last 50)
  ========================== */
  const CHAT_MAX = 50;
  function startChatListener(){
    db.collection('chat').orderBy('timestamp','desc').limit(CHAT_MAX).onSnapshot(snap=>{
      const arr = [];
      snap.forEach(d=>arr.push(d.data()));
      arr.reverse();
      chatMessagesEl.innerHTML = '';
      arr.forEach(m=>{
        const time = m.timestamp ? new Date(m.timestamp.seconds*1000).toLocaleTimeString() : '';
        const div = document.createElement('div');
        div.textContent = `[${time}] ${m.name||'Player'}: ${m.message||''}`;
        chatMessagesEl.appendChild(div);
      });
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    });
  }
  async function sendMessage(text){
    const t = (text||'').trim();
    if (!t) return;
    await db.collection('chat').add({
      name: playerName || 'Player',
      message: t,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });
    // Trim > 50
    const all = await db.collection('chat').orderBy('timestamp','asc').get();
    if (all.size > CHAT_MAX){
      const toDelete = all.docs.slice(0, all.size-CHAT_MAX);
      const batch = db.batch();
      toDelete.forEach(doc=>batch.delete(doc.ref));
      await batch.commit();
    }
  }
  chatInputEl.addEventListener('keydown', e=>{
    if (e.key === 'Enter'){
      e.preventDefault();
      sendMessage(chatInputEl.value);
      chatInputEl.value='';
    }
  });

  /* =========================
     THREE / Game
  ========================== */
  const ARENA_RADIUS = 120;
  const SEGMENT_DISTANCE = 6;
  const BOOST_MULTIPLIER = 2.4;
  const BOOST_DURATION = 2000;
  const BOOST_COOLDOWN = 4000;
  const OBSTACLE_COUNT = 10;
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0b0f14, 0.0025);
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.5, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x1b2230, 1);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(50, 100, 50); scene.add(dirLight);

  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(ARENA_RADIUS, 64),
    new THREE.MeshStandardMaterial({color:0x0d3b66})
  );
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  function makeCar(color=0xff2d55){
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(3.4, 1.2, 7.6), new THREE.MeshStandardMaterial({color}));
    body.position.y = 0.6; g.add(body);
    return g;
  }

  const cars = [];
  cars.push({
    position: new THREE.Vector3(0,0,0),
    rotationY: 0,
    mesh: makeCar(0xff2d55),
    boost: {active:false, cooldown:0, timer:0}
  });
  scene.add(cars[0].mesh);
  cars[0].mesh.position.set(0,0,0);

  function addFollower(){
    const leader = cars[cars.length-1];
    const follower = {
      position: new THREE.Vector3().copy(leader.position),
      rotationY: leader.rotationY,
      mesh: makeCar(0xff8a00),
    };
    const back = new THREE.Vector3(0,0,-SEGMENT_DISTANCE).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotationY);
    follower.position.add(back);
    scene.add(follower.mesh);
    cars.push(follower);
  }

  const pickups = [];
  function spawnPickup(){
    const r = THREE.MathUtils.randFloat(10, ARENA_RADIUS-10);
    const a = THREE.MathUtils.randFloat(0, Math.PI*2);
    const x = Math.cos(a)*r, z = Math.sin(a)*r;
    const cone = new THREE.Mesh(new THREE.ConeGeometry(1.2,2.2,10), new THREE.MeshStandardMaterial({color:0x00ffae}));
    cone.position.set(x,1.1,z); cone.rotation.x = Math.PI;
    scene.add(cone); pickups.push(cone);
  }
  for(let i=0;i<6;i++) spawnPickup();

  const obstacles = [];
  function spawnObstacles(){
    for(let i=0;i<OBSTACLE_COUNT;i++){
      const r = THREE.MathUtils.randFloat(15, ARENA_RADIUS-15);
      const a = THREE.MathUtils.randFloat(0, Math.PI*2);
      const x = Math.cos(a)*r, z = Math.sin(a)*r;
      const box = new THREE.Mesh(new THREE.BoxGeometry(6,6,6), new THREE.MeshStandardMaterial({color:0xaa0000}));
      box.position.set(x,3,z); scene.add(box); obstacles.push(box);
    }
  }
  spawnObstacles();

  const keys = {};
  window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup',   e=> keys[e.key.toLowerCase()] = false);

  let touchLeft=false, touchRight=false, lastTap=0;
  function handleTouchStart(e){
    e.preventDefault();
    if (e.touches.length===1){
      const x = e.touches[0].clientX;
      (x < innerWidth/2) ? touchLeft=true : touchRight=true;
    } else if (e.touches.length===2){
      if (canBoost(cars[0])) startBoost(cars[0]);
    }
  }
  function handleTouchEnd(e){ e.preventDefault(); touchLeft=false; touchRight=false; }
  function handleTap(){
    const now = Date.now();
    if (now - lastTap < 300){ if (canBoost(cars[0])) startBoost(cars[0]); }
    lastTap = now;
  }
  window.addEventListener('touchstart', handleTouchStart, {passive:false});
  window.addEventListener('touchend',   handleTouchEnd,   {passive:false});
  window.addEventListener('touchcancel',handleTouchEnd,   {passive:false});
  window.addEventListener('click', handleTap);

  function canBoost(car){
    const t = performance.now();
    if (car.boost.cooldown && t < car.boost.cooldown) return false;
    return true;
  }
  function startBoost(car){
    const t = performance.now();
    car.boost.active = true;
    car.boost.timer = t + BOOST_DURATION;
    car.boost.cooldown = t + BOOST_DURATION + BOOST_COOLDOWN;
  }
  function updateBoost(car){
    const t = performance.now();
    if (car.boost.active && t > car.boost.timer) car.boost.active = false;
  }

  /* =========================
     Game loop
  ========================== */
  let lastTime = performance.now();
  function animate(){
    requestAnimationFrame(animate);

    const now = performance.now();
    const dtRaw = (now - lastTime)/1000;
    const dt = Math.min(dtRaw, 0.05);
    lastTime = now;

    // Render even if not alive (for overlay background)
    const player = cars[0];

    // Movement
    const BASE_SPEED = isMobile ? 7 : 15;
    const ROTATION_SPEED = isMobile ? 2.5 : 3.5;

    if (alive){
      if (keys['a'] || keys['arrowleft']  || touchLeft)  player.rotationY += ROTATION_SPEED * dt;
      if (keys['d'] || keys['arrowright'] || touchRight) player.rotationY -= ROTATION_SPEED * dt;

      if ((keys[' '] && canBoost(player)) || player.boost.active){
        if (keys[' '] && canBoost(player)) startBoost(player);
      }
      updateBoost(player);

      const speed = BASE_SPEED * (player.boost.active ? BOOST_MULTIPLIER : 1);
      const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotationY);
      player.position.add(fwd.multiplyScalar(speed * dt));

      // followers
      for (let i=1;i<cars.length;i++){
        const lead = cars[i-1], foll = cars[i];
        const dir = new THREE.Vector3().subVectors(lead.position, foll.position);
        const dist = dir.length();
        if (dist > SEGMENT_DISTANCE){
          dir.normalize();
          foll.position.add(dir.multiplyScalar(Math.min(dist-SEGMENT_DISTANCE, speed*dt*1.5)));
        }
        const targetRot = Math.atan2(dir.x, dir.z);
        foll.rotationY += (targetRot - foll.rotationY) * 0.15;
      }

      // apply transforms
      for (let i=0;i<cars.length;i++){
        const c = cars[i];
        c.mesh.position.copy(c.position).setY(0.6);
        c.mesh.rotation.y = c.rotationY;
      }

      // pickups
      for (let i=pickups.length-1; i>=0; i--){
        if (pickups[i].position.distanceTo(player.position) < 3){
          scene.remove(pickups[i]); pickups.splice(i,1);
          score++; scoreEl.textContent = score;
          addFollower(); spawnPickup();
        }
      }

      // obstacles
      for (const o of obstacles){
        if (o.position.distanceTo(player.position) < 4.5){
          doGameOver(); break;
        }
      }

      // boundary
      if (player.position.length() > ARENA_RADIUS){
        doGameOver();
      }
    }

    // camera
    const camOffset = new THREE.Vector3(0, 15, -30).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotationY);
    camera.position.copy(player.position.clone().add(camOffset));
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  function doGameOver(){
    if (!alive) return;
    alive = false;
    scoreEl.textContent = score;
    // submit on death (same behavior you had)
    if (!leaderboardSubmitted){
      leaderboardSubmitted = true;
      submitScore(playerName || 'Player', score);
    }
    // show restart overlay with prefilled name
    document.getElementById('finalScore').textContent = score;
    restartNameInput.value = playerName || '';
    restartOverlay.style.display = 'grid';
  }

  /* =========================
     Start / Restart UX
  ========================== */
  startBtn.addEventListener('click', () => {
    const nm = (nameInput.value || '').trim().substring(0,20);
    if (!nm){ nameInput.focus(); return; }
    playerName = nm; localStorage.setItem('f1snake_name', playerName);
    score = 0; scoreEl.textContent = '0'; leaderboardSubmitted = false; alive = true;
    chatBox.style.display = 'flex';
    startOverlay.style.display = 'none';
    // also focus chat input on start for convenience
    setTimeout(()=> chatInputEl.blur(), 0);
  });
  nameInput.addEventListener('keydown', e=>{ if (e.key==='Enter') startBtn.click(); });

  restartBtn.addEventListener('click', () => {
    const nm = (restartNameInput.value || '').trim().substring(0,20);
    playerName = nm || playerName || 'Player';
    localStorage.setItem('f1snake_name', playerName);
    // reset game state
    score = 0; scoreEl.textContent = '0'; leaderboardSubmitted = false; alive = true;
    // reposition player & clear followers (go back to just the head)
    while (cars.length > 1){
      const seg = cars.pop(); scene.remove(seg.mesh);
    }
    cars[0].position.set(0,0,0); cars[0].rotationY = 0;
    cars[0].mesh.position.set(0,0,0); cars[0].mesh.rotation.y = 0;
    // hide overlay
    restartOverlay.style.display = 'none';
  });

  // Show chat only after name entered; but start listening immediately so messages render once visible
  startChatListener();

  // start the render loop immediately so overlays have animated background
  animate();

  // responsive
  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
})();
</script>
</body>
</html>
