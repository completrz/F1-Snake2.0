<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>F1 Snake ‚Äî Leaderboard + Chat + Prime Karambit</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  :root{
    --glass: rgba(0,0,0,0.35);
    --panel: rgba(0,0,0,0.75);
    --accent: #00e5ff;
  }
  html, body {
    margin: 0; height: 100%; overflow: hidden; background: #87b6ff;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: #fff;
    touch-action: none;
  }

  /* Left HUD */
  #hud {
    position: absolute; top: 14px; left: 14px; z-index: 30;
    background: var(--glass); padding: 10px 12px; border-radius: 12px;
    backdrop-filter: blur(6px); width: 260px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }
  #scoreRow { font-weight: 700; font-size: 18px; display:flex; justify-content:space-between; }
  #timer { font-variant-numeric: tabular-nums; opacity:.95; }
  #hint   { margin-top: 6px; font-size: 12px; opacity: .85; line-height: 1.35; }

  /* Chat (square, under instructions, left) */
  #chat {
    margin-top: 10px;
    width: 260px; height: 260px;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    display: none;            /* shown after name entered */
    flex-direction: column;
    overflow: hidden;
  }
  #chatHeader{
    padding: 8px 10px; font-size: 12px; letter-spacing:.2px; opacity:.9;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  #chatMessages {
    flex: 1; overflow-y: auto; padding: 8px 10px; line-height: 1.35; font-size: 13px;
  }
  #chatInput {
    border: none; outline: none; padding: 10px;
    background: #141920; color: #fff; font-size: 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
  }
  #chatInput::placeholder{ color:#8aa0b4; }

  /* Right column (leaderboard) */
  #rightCol{
    position: absolute; top: 14px; right: 14px; z-index: 30;
    width: 320px; display:flex; flex-direction:column; gap: 12px;
  }
  #leaderboard {
    width: 100%; max-height: 420px; overflow-y: auto;
    background: var(--panel); border: 1px solid rgba(255,255,255,0.08);
    border-radius: 14px; box-shadow: 0 6px 22px rgba(0,0,0,0.45);
    backdrop-filter: blur(6px);
  }
  #lbHeader{
    padding: 10px 14px; border-bottom: 1px solid rgba(255,255,255,0.08);
    display:flex; align-items:center; gap:8px;
  }
  #lbHeader .dot{ width:8px; height:8px; border-radius:50%; background: var(--accent); box-shadow:0 0 10px var(--accent); }
  #lbHeader h3{ margin:0; font-size: 14px; letter-spacing:.3px; font-weight: 700; }
  #lbList{ list-style:none; margin:0; padding: 8px 10px 12px 10px; }
  #lbList li{
    display:flex; justify-content: space-between; align-items:center;
    padding: 8px 8px; margin: 4px 0;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px; font-size: 14px;
  }
  #lbList li .rank{
    width: 22px; height: 22px; border-radius: 6px; display:flex; align-items:center; justify-content:center;
    background: rgba(255,255,255,0.08); font-size: 12px; margin-right: 8px;
  }
  #lbList li .name{ flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  #lbList li .score{ font-weight: 700; color: #b7f; }

  /* Overlays (start/restart) */
  .overlay {
    position: fixed; inset: 0; display: none; place-items: center; z-index: 50;
    background: radial-gradient(60% 60% at 50% 50%, rgba(0,229,255,0.08), rgba(0,0,0,0.55));
    animation: fadeIn .25s ease-out both;
  }
  @keyframes fadeIn { from{opacity:0} to{opacity:1} }
  .panel {
    width: min(560px, 92vw);
    background: rgba(10,14,20,.85);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    padding: 22px 22px 18px;
    text-align: center; backdrop-filter: blur(10px);
  }
  .title { font-weight: 800; font-size: 28px; letter-spacing:.3px; margin: 4px 0 6px; }
  .subtitle { opacity:.85; font-size: 14px; margin-bottom: 14px; }
  .inputRow { display:flex; gap:10px; justify-content:center; margin-top: 8px; }
  .textInput {
    width: 260px; padding: 10px 12px; border-radius: 10px; border:1px solid rgba(255,255,255,.12);
    outline:none; background:#0f1620; color:#fff; font-size:15px;
  }
  .btn {
    padding: 10px 16px; border-radius: 10px; border: none; cursor: pointer;
    background: linear-gradient(90deg, #00c6ff, #0072ff); color:#001318; font-weight: 800;
    text-transform: uppercase; letter-spacing:.4px;
    box-shadow: 0 10px 24px rgba(0,114,255,.35);
  }
  .btn:hover{ filter: brightness(1.07); }
  .small { font-size:12px; opacity:.8; margin-top:10px; }
  .scoreBadge{
    display:inline-block; padding: 6px 10px; border-radius: 999px;
    background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12);
    margin-bottom: 8px; font-weight:700;
  }
</style>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
</head>
<body>

<!-- Left HUD -->
<div id="hud">
  <div id="scoreRow">
    <span>Score: <span id="score">0</span></span>
    <span id="timer">00:00</span>
  </div>
  <div id="hint">Controls: A/D or ‚óÄÔ∏è/‚ñ∂Ô∏è ‚Ä¢ Touch left/right ‚Ä¢ Double-tap/2-finger = Boost ‚Ä¢ Press <b>F</b> to inspect</div>

  <div id="chat">
    <div id="chatHeader">üí¨ Global Chat</div>
    <div id="chatMessages"></div>
    <input id="chatInput" placeholder="Type & press Enter" autocomplete="off" />
  </div>
</div>

<!-- Right column -->
<div id="rightCol">
  <div id="leaderboard">
    <div id="lbHeader"><span class="dot"></span><h3>Top 10 ‚Äî Global Leaderboard</h3></div>
    <ul id="lbList"><li><span class="rank">‚Äì</span><span class="name">Loading‚Ä¶</span><span class="score">‚Äì</span></li></ul>
  </div>
</div>

<!-- Start overlay -->
<div id="startOverlay" class="overlay" style="display:grid;">
  <div class="panel">
    <div class="title">F1 Snake</div>
    <div class="subtitle">Collect fuel cells anywhere in the arena. Avoid barriers. Boost wisely!</div>
    <div class="inputRow">
      <input id="nameInput" class="textInput" maxlength="20" placeholder="Player name" />
      <button id="startBtn" class="btn">Start</button>
    </div>
    <div class="small">Your last name is remembered on this device.</div>
  </div>
</div>

<!-- Restart overlay -->
<div id="restartOverlay" class="overlay">
  <div class="panel">
    <div class="title">Game Over</div>
    <div class="scoreBadge">Final Score: <span id="finalScore">0</span></div>
    <div class="inputRow">
      <input id="restartNameInput" class="textInput" maxlength="20" placeholder="Player name" />
      <button id="restartBtn" class="btn">Restart</button>
    </div>
    <div class="small">Change your name or keep it the same.</div>
  </div>
</div>

<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script>
(() => {
  /* ========= Firebase ========= */
  const firebaseConfig = {
    apiKey: "AIzaSyC5seSlgxk4mCRn4HKet4rHlzhQVVBxc-8",
    authDomain: "f1-snake.firebaseapp.com",
    projectId: "f1-snake",
    storageBucket: "f1-snake.firebasestorage.app",
    messagingSenderId: "575341092161",
    appId: "1:575341092161:web:b9050e1df88c9e36de95c0"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  /* ========= DOM ========= */
  const startOverlay = document.getElementById('startOverlay');
  const restartOverlay = document.getElementById('restartOverlay');
  const nameInput = document.getElementById('nameInput');
  const startBtn = document.getElementById('startBtn');
  const restartNameInput = document.getElementById('restartNameInput');
  const restartBtn = document.getElementById('restartBtn');
  const scoreEl = document.getElementById('score');
  const timerEl = document.getElementById('timer');
  const chatBox = document.getElementById('chat');
  const chatMessagesEl = document.getElementById('chatMessages');
  const chatInputEl = document.getElementById('chatInput');
  const lbList = document.getElementById('lbList');

  /* ========= State ========= */
  let playerName = localStorage.getItem('f1snake_name') || '';
  if (playerName) { nameInput.value = playerName; }
  let alive = false;
  let score = 0;
  let leaderboardSubmitted = false;
  let gameStartMs = 0;
  let spawnGraceUntil = 0; // ms timestamp for spawn invulnerability

  /* ========= Leaderboard ========= */
  function startLeaderboardListener(){
    db.collection('leaderboard').orderBy('score','desc').limit(10).onSnapshot(snap=>{
      lbList.innerHTML = '';
      let rank = 1;
      snap.forEach(doc=>{
        const d = doc.data();
        const li = document.createElement('li');
        li.innerHTML = `<span class="rank">${rank}</span>
                        <span class="name">${(d.name||'Player')}</span>
                        <span class="score">${d.score||0}</span>`;
        lbList.appendChild(li);
        rank++;
      });
      if (rank === 1){
        const li = document.createElement('li');
        li.innerHTML = `<span class="rank">‚Äì</span><span class="name">No scores yet</span><span class="score">‚Äì</span>`;
        lbList.appendChild(li);
      }
    });
  }
  startLeaderboardListener();

  async function submitScore(name, scoreVal){
    try{
      const q = await db.collection('leaderboard').where('name','==',name).limit(1).get();
      if (!q.empty){
        const docRef = q.docs[0].ref;
        const prev = q.docs[0].data().score || 0;
        if (scoreVal > prev){
          await docRef.update({score: scoreVal, timestamp: firebase.firestore.FieldValue.serverTimestamp()});
        }
      } else {
        await db.collection('leaderboard').add({
          name, score: scoreVal, timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    }catch(e){ console.error(e); }
  }

  /* ========= Chat (last 50) ========= */
  const CHAT_MAX = 50;
  function startChatListener(){
    db.collection('chat').orderBy('timestamp','desc').limit(CHAT_MAX).onSnapshot(snap=>{
      const arr = [];
      snap.forEach(d=>arr.push(d.data()));
      arr.reverse();
      chatMessagesEl.innerHTML = '';
      arr.forEach(m=>{
        const time = m.timestamp ? new Date(m.timestamp.seconds*1000).toLocaleTimeString() : '';
        const div = document.createElement('div');
        div.textContent = `[${time}] ${m.name||'Player'}: ${m.message||''}`;
        chatMessagesEl.appendChild(div);
      });
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    });
  }
  async function sendMessage(text){
    const t = (text||'').trim();
    if (!t) return;
    await db.collection('chat').add({
      name: playerName || 'Player',
      message: t,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });
    // Trim > 50
    const all = await db.collection('chat').orderBy('timestamp','asc').get();
    if (all.size > CHAT_MAX){
      const toDelete = all.docs.slice(0, all.size-CHAT_MAX);
      const batch = db.batch();
      toDelete.forEach(doc=>batch.delete(doc.ref));
      await batch.commit();
    }
  }
  chatInputEl.addEventListener('keydown', e=>{
    if (e.key === 'Enter'){
      e.preventDefault();
      sendMessage(chatInputEl.value);
      chatInputEl.value='';
    }
  });

  /* ========= THREE / Scene ========= */
  const ARENA_RADIUS = 120;
  const TRACK_WIDTH = 28;
  const trackInner = ARENA_RADIUS - TRACK_WIDTH;

  const SEGMENT_DISTANCE = 6;
  const BOOST_MULTIPLIER = 2.4;
  const BOOST_DURATION = 2000;
  const BOOST_COOLDOWN = 4000;
  const OBSTACLE_COUNT = 12;
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x9cc6ff, 0.0009);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.5, 2000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  /* ---------- Sky Dome ---------- */
  function makeSkyDome(){
    const c = document.createElement('canvas');
    c.width = 2; c.height = 256;
    const ctx = c.getContext('2d');
    const grd = ctx.createLinearGradient(0,0,0,256);
    grd.addColorStop(0,   '#83b8ff');
    grd.addColorStop(0.6, '#a9ccff');
    grd.addColorStop(1,   '#d8e8ff');
    ctx.fillStyle = grd; ctx.fillRect(0,0,2,256);
    const tex = new THREE.CanvasTexture(c);
    tex.magFilter = THREE.LinearFilter;
    const geo = new THREE.SphereGeometry(1500, 32, 16);
    const mat = new THREE.MeshBasicMaterial({map: tex, side: THREE.BackSide});
    return new THREE.Mesh(geo, mat);
  }
  scene.add(makeSkyDome());

  /* ---------- Lights ---------- */
  const hemiLight = new THREE.HemisphereLight(0xcfe3ff, 0x8fb3d9, 0.6);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(60, 120, 40);
  scene.add(dirLight);

  /* ---------- Track / Ground ---------- */
  // Playable everywhere on the disc; ring visuals only
  const grass = new THREE.Mesh(
    new THREE.CircleGeometry(ARENA_RADIUS, 128),
    new THREE.MeshStandardMaterial({color:0x7bbf5d, roughness:0.95, metalness:0.0})
  );
  grass.rotation.x = -Math.PI/2;
  grass.receiveShadow = true;
  scene.add(grass);

  const asphalt = new THREE.Mesh(
    new THREE.RingGeometry(trackInner, ARENA_RADIUS, 256),
    new THREE.MeshStandardMaterial({color:0x2f3238, roughness:0.95, metalness:0.0})
  );
  asphalt.rotation.x = -Math.PI/2;
  asphalt.position.y = 0.01;
  scene.add(asphalt);

  function curbTexture(){
    const c = document.createElement('canvas');
    c.width = 512; c.height = 16;
    const ctx = c.getContext('2d');
    const stripeW = 32;
    for(let x=0;x<c.width;x+=stripeW){
      ctx.fillStyle = (Math.floor(x/stripeW)%2===0)?'#ffffff':'#d10';
      ctx.fillRect(x,0,stripeW,c.height);
    }
    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.repeat.set(4,1);
    return tex;
  }
  const curbMatOuter = new THREE.MeshBasicMaterial({map: curbTexture(), side: THREE.DoubleSide});
  const curbMatInner = new THREE.MeshBasicMaterial({map: curbTexture(), side: THREE.DoubleSide});
  const curbOuter = new THREE.Mesh(new THREE.RingGeometry(ARENA_RADIUS-1.5, ARENA_RADIUS-0.2, 256), curbMatOuter);
  curbOuter.rotation.x = -Math.PI/2; curbOuter.position.y = 0.015; scene.add(curbOuter);
  const curbInner = new THREE.Mesh(new THREE.RingGeometry(trackInner+0.2, trackInner+1.5, 256), curbMatInner);
  curbInner.rotation.x = -Math.PI/2; curbInner.position.y = 0.015; scene.add(curbInner);

  /* ---------- Start grid decal ---------- */
  function makeCheckeredTile(){
    const c = document.createElement('canvas');
    c.width = c.height = 128;
    const ctx = c.getContext('2d');
    for(let y=0;y<8;y++){
      for(let x=0;x<8;x++){
        ctx.fillStyle = ((x+y)%2===0) ? '#111' : '#eee';
        ctx.fillRect(x*16,y*16,16,16);
      }
    }
    return new THREE.CanvasTexture(c);
  }
  const gridMat = new THREE.MeshBasicMaterial({ map: makeCheckeredTile(), transparent:true, opacity:0.75 });
  const gridMesh = new THREE.Mesh(new THREE.PlaneGeometry(12,6), gridMat);
  gridMesh.rotation.x = -Math.PI/2;
  gridMesh.position.set(0,0.02, -ARENA_RADIUS + 14);
  scene.add(gridMesh);

  /* ---------- Car Models ---------- */
  function makeHeadCar(primary=0xff2d55, accent=0xffffff){
    const g = new THREE.Group();
    const wheelMat = new THREE.MeshStandardMaterial({color:0x111111, metalness:.3, roughness:.6});
    const wheelGeo = new THREE.CylinderGeometry(0.6,0.6,0.4,16);
    const wheels = [0,1,2,3].map(()=>new THREE.Mesh(wheelGeo, wheelMat));
    wheels.forEach(w=>{ w.rotation.z = Math.PI/2; w.castShadow = true; w.receiveShadow=true; g.add(w); });
    wheels[0].position.set(-1.2, 0.6,  2.2);
    wheels[1].position.set( 1.2, 0.6,  2.2);
    wheels[2].position.set(-1.2, 0.6, -2.0);
    wheels[3].position.set( 1.2, 0.6, -2.0);
    const bodyMat = new THREE.MeshStandardMaterial({color:primary, metalness:.5, roughness:.3});
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.6,5.6), bodyMat);
    body.position.set(0, 0.9, 0); body.castShadow = true; g.add(body);
    const pod = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,3.6), bodyMat);
    const pod2 = pod.clone(); pod.position.set(-1.4, 0.85, 0); pod2.position.set(1.4, 0.85, 0); g.add(pod); g.add(pod2);
    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.0,0.5,1.2),
      new THREE.MeshStandardMaterial({color:accent, metalness:.2, roughness:.6}));
    cockpit.position.set(0, 1.25, 1.0); cockpit.castShadow = true; g.add(cockpit);
    const fwing = new THREE.Mesh(new THREE.BoxGeometry(3.2,0.15,0.9), bodyMat); fwing.position.set(0, 0.75, 3.1); g.add(fwing);
    const rwing = new THREE.Mesh(new THREE.BoxGeometry(2.4,0.15,0.6), bodyMat); rwing.position.set(0, 1.15, -2.8); g.add(rwing);
    const rwingVert = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.7,0.05), bodyMat); rwingVert.position.set(0, 1.0, -2.6); g.add(rwingVert);
    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.5,1.2,14), bodyMat); nose.rotation.x = Math.PI; nose.position.set(0,0.95,3.5); g.add(nose);
    return g;
  }
  function makeTailCar(primary=0xff8a00, trim=0x333333){
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.5,4.2),
      new THREE.MeshStandardMaterial({color:primary, metalness:.4, roughness:.4}));
    body.position.set(0,0.85,0); g.add(body);
    const bump = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.35,0.9),
      new THREE.MeshStandardMaterial({color:0xffffff, metalness:.2, roughness:.6}));
    bump.position.set(0,1.1,0.6); g.add(bump);
    const wing = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.12,0.45),
      new THREE.MeshStandardMaterial({color:primary, metalness:.4, roughness:.4}));
    wing.position.set(0,1.05,-2.1); g.add(wing);
    const wheelMat = new THREE.MeshStandardMaterial({color:trim, metalness:.3, roughness:.6});
    const wheelGeo = new THREE.CylinderGeometry(0.5,0.5,0.3,14);
    const w1 = new THREE.Mesh(wheelGeo, wheelMat), w2 = new THREE.Mesh(wheelGeo, wheelMat);
    w1.rotation.z = Math.PI/2; w2.rotation.z = Math.PI/2;
    w1.position.set(-1.1,0.6,0.8); w2.position.set(1.1,0.6,0.8); g.add(w1); g.add(w2);
    return g;
  }

  // Cars
  const cars = [];
  cars.push({
    position: new THREE.Vector3(0,0,0),
    rotationY: 0,
    mesh: makeHeadCar(0xff2d55, 0xbfd8ff),
    boost: {active:false, cooldown:0, timer:0}
  });
  scene.add(cars[0].mesh);
  cars[0].mesh.position.set(0,0,0);

  function addFollower(){
    const leader = cars[cars.length-1];
    const follower = {
      position: new THREE.Vector3().copy(leader.position),
      rotationY: leader.rotationY,
      mesh: makeTailCar(0xff8a00, 0x222222),
    };
    const back = new THREE.Vector3(0,0,-SEGMENT_DISTANCE).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotationY);
    follower.position.add(back);
    scene.add(follower.mesh);
    cars.push(follower);
  }

  /* ---------- Pickups (spawn across entire arena) ---------- */
  const pickups = [];
  function createFuelCell(){
    const group = new THREE.Group();
    const core = new THREE.Mesh(
      new THREE.IcosahedronGeometry(1.0, 0),
      new THREE.MeshStandardMaterial({color:0x00ffae, emissive:0x00ffae, emissiveIntensity:0.6, roughness:0.3, metalness:0.2})
    );
    core.position.y = 1.0;
    group.add(core);
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(1.2, 0.06, 12, 40),
      new THREE.MeshBasicMaterial({color:0x66ffd9, transparent:true, opacity:0.6})
    );
    ring.rotation.x = Math.PI/2; ring.position.y = 1.0; group.add(ring);
    return group;
  }
  function randomPointInCircle(minR, maxR){
    const u = Math.random();
    const r = Math.sqrt(u) * (maxR - minR) + minR;
    const a = Math.random() * Math.PI * 2;
    return new THREE.Vector3(Math.cos(a)*r, 0, Math.sin(a)*r);
  }
  function spawnPickup(){
    const p = createFuelCell();
    const pos = randomPointInCircle(6, ARENA_RADIUS - 6);
    p.position.copy(pos);
    scene.add(p);
    pickups.push({mesh:p, baseY:0, phase: Math.random()*Math.PI*2});
  }
  for(let i=0;i<10;i++) spawnPickup();

  /* ---------- Obstacles: scatter through arena ---------- */
  const obstacles = [];
  const barrelMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    map: (()=>{ const c=document.createElement('canvas'); c.width=128; c.height=64;
      const ctx=c.getContext('2d'); for(let i=0;i<6;i++){ ctx.fillStyle=(i%2===0)?'#d10':'#fff'; ctx.fillRect(0,i*(c.height/6),c.width,(c.height/6)); }
      const t = new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; return t; })(),
    metalness: 0.2, roughness: 0.7
  });
  function makeBarrier(){
    const g = new THREE.Group();
    const cyl = new THREE.Mesh(new THREE.CylinderGeometry(2,2,4,24,1,true), barrelMat);
    cyl.position.y = 2; g.add(cyl);
    const capMat = new THREE.MeshStandardMaterial({color:0x2f3238, metalness:0.2, roughness:0.6});
    const capTop = new THREE.Mesh(new THREE.CircleGeometry(2,24), capMat);
    capTop.rotation.x = -Math.PI/2; capTop.position.y = 4; g.add(capTop);
    const capBottom = new THREE.Mesh(new THREE.CircleGeometry(2,24), capMat);
    capBottom.rotation.x =  Math.PI/2; capBottom.position.y = 0; g.add(capBottom);
    const light = new THREE.Mesh(new THREE.SphereGeometry(0.25,12,12), new THREE.MeshStandardMaterial({color:0xff4040, emissive:0xff4040, emissiveIntensity:1.2}));
    light.position.set(0,4.4,0); g.add(light);
    return g;
  }
  function spawnObstacles(){
    for(let i=0;i<OBSTACLE_COUNT;i++){
      const pos = randomPointInCircle(10, ARENA_RADIUS - 12);
      const b = makeBarrier(); b.position.copy(pos); scene.add(b);
      const mode = (i % 2 === 0) ? 'circle' : 'bounce';
      const amp = THREE.MathUtils.randFloat(6, 12);
      const freq = THREE.MathUtils.randFloat(0.15, 0.45);
      const phase = Math.random() * Math.PI * 2;
      let dir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5);
      if (dir.lengthSq() < 0.01) dir.set(1,0,0);
      dir.normalize();
      obstacles.push({ mesh:b, base: b.position.clone(), mode, amp, freq, phase, dir });
    }
  }
  spawnObstacles();

  /* ---------- INPUT ---------- */
  const keys = {};
  window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup',   e=> keys[e.key.toLowerCase()] = false);

  let touchLeft=false, touchRight=false, lastTap=0;
  function handleTouchStart(e){
    e.preventDefault();
    if (e.touches.length===1){
      const x = e.touches[0].clientX;
      (x < innerWidth/2) ? touchLeft=true : touchRight=true;
    } else if (e.touches.length===2){
      if (canBoost(cars[0])) startBoost(cars[0]);
    }
  }
  function handleTouchEnd(e){ e.preventDefault(); touchLeft=false; touchRight=false; }
  function handleTap(){
    const now = Date.now();
    if (now - lastTap < 300){ if (canBoost(cars[0])) startBoost(cars[0]); }
    lastTap = now;
  }
  window.addEventListener('touchstart', handleTouchStart, {passive:false});
  window.addEventListener('touchend',   handleTouchEnd,   {passive:false});
  window.addEventListener('touchcancel',handleTouchEnd,   {passive:false});
  window.addEventListener('click', handleTap);

  function canBoost(car){
    const t = performance.now();
    if (car.boost.cooldown && t < car.boost.cooldown) return false;
    return true;
  }
  function startBoost(car){
    const t = performance.now();
    car.boost.active = true;
    car.boost.timer = t + BOOST_DURATION;
    car.boost.cooldown = t + BOOST_DURATION + BOOST_COOLDOWN;
  }
  function updateBoost(car){
    const t = performance.now();
    if (car.boost.active && t > car.boost.timer) car.boost.active = false;
  }

  /* ---------- FIRST-PERSON KNIFE: Prime Karambit look-alike ---------- */
  const knife = {
    group:null, basePos:new THREE.Vector3(0.7,-0.55,-1.1), baseRot:new THREE.Euler(-0.15, 0.55, 0.25),
    spin:false, spinStart:0, spinDur:1200
  };

  function goldMaterial(){
    return new THREE.MeshStandardMaterial({color:0xffd76b, metalness:1.0, roughness:0.25, emissive:0x2a2205, emissiveIntensity:0.05});
  }
  function purpleMaterial(){
    return new THREE.MeshStandardMaterial({color:0x6b4bff, metalness:0.6, roughness:0.35, emissive:0x120a3a, emissiveIntensity:0.08});
  }
  function bladeMaterial(){
    return new THREE.MeshStandardMaterial({color:0xe8e8f0, metalness:1.0, roughness:0.16});
  }
  function edgeMaterial(){
    return new THREE.MeshStandardMaterial({color:0xffffff, metalness:1.0, roughness:0.08});
  }

  function makePrimeKarambit(){
    const g = new THREE.Group();

    // Curved blade using torus segment + thinner "edge" overlay for bevel look
    const arc = Math.PI * 1.15; // more than half circle
    const bladeGeo = new THREE.TorusGeometry(0.9, 0.09, 20, 120, arc);
    const blade = new THREE.Mesh(bladeGeo, bladeMaterial());
    blade.rotation.x = Math.PI/2;
    blade.rotation.z = Math.PI/2.9;
    blade.position.set(0.18, 0.0, 0.06);
    g.add(blade);

    const edgeGeo = new THREE.TorusGeometry(0.9, 0.05, 12, 120, arc);
    const edge = new THREE.Mesh(edgeGeo, edgeMaterial());
    edge.rotation.copy(blade.rotation);
    edge.position.copy(blade.position);
    edge.scale.set(1.02,1.02,1.02);
    g.add(edge);

    // Gold spine accents along blade (thin arcs)
    const spineGeo = new THREE.TorusGeometry(0.88, 0.02, 8, 80, arc*0.92);
    const spine = new THREE.Mesh(spineGeo, goldMaterial());
    spine.rotation.copy(blade.rotation);
    spine.position.copy(blade.position);
    spine.rotation.z += 0.06;
    g.add(spine);

    // Handle grip
    const grip = new THREE.Mesh(new THREE.CapsuleGeometry(0.10, 0.6, 8, 16), purpleMaterial());
    grip.rotation.z = Math.PI/6;
    grip.position.set(-0.42, -0.02, -0.06);
    g.add(grip);

    // Finger ring (gold outer, purple inner)
    const ringOuter = new THREE.Mesh(new THREE.TorusGeometry(0.19, 0.055, 16, 24), goldMaterial());
    ringOuter.rotation.x = Math.PI/2;
    ringOuter.position.set(-0.68, 0.02, -0.10);
    g.add(ringOuter);

    const ringInner = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.025, 12, 20), purpleMaterial());
    ringInner.rotation.x = Math.PI/2;
    ringInner.position.copy(ringOuter.position);
    g.add(ringInner);

    // Guard + emblem plate
    const guard = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.14, 0.32), goldMaterial());
    guard.rotation.z = Math.PI/6;
    guard.position.set(-0.24, -0.03, -0.05);
    g.add(guard);

    const emblem = new THREE.Mesh(new THREE.CircleGeometry(0.08, 20), goldMaterial());
    emblem.rotation.y = Math.PI/2;
    emblem.position.set(-0.12, 0.02, -0.06);
    g.add(emblem);

    // Tiny screws on the grip
    const screwMat = new THREE.MeshStandardMaterial({color:0xcfd2d7, metalness:0.9, roughness:0.2});
    for (let i=0;i<2;i++){
      const s = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.06,12), screwMat);
      s.rotation.x = Math.PI/2;
      s.position.set(-0.30 + 0.16*i, 0.05, -0.06);
      g.add(s);
    }

    // Slight emissive glow strip (Prime vibe)
    const glow = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.02,0.36),
      new THREE.MeshStandardMaterial({color:0xbdd4ff, emissive:0x7bb1ff, emissiveIntensity:0.7, metalness:0.3, roughness:0.6}));
    glow.rotation.z = Math.PI/6;
    glow.position.set(-0.38, 0.07, -0.05);
    g.add(glow);

    return g;
  }

  function addKnifeToCamera(){
    knife.group = makePrimeKarambit();
    camera.add(knife.group);
    knife.group.position.copy(knife.basePos);
    knife.group.rotation.copy(knife.baseRot);
    scene.add(camera);
  }

  function startSpin(){
    if (!knife.group || knife.spin) return;
    knife.spin = true;
    knife.spinStart = performance.now();
  }

  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() === 'f') startSpin();
  });

  function updateKnife(dt){
    if (!knife.group) return;

    // idle sway
    const t = performance.now() * 0.001;
    knife.group.position.y = knife.basePos.y + Math.sin(t*2.2)*0.01;
    knife.group.rotation.x = knife.baseRot.x + Math.sin(t*1.6)*0.01;

    if (knife.spin){
      const now = performance.now();
      const p = Math.min(1, (now - knife.spinStart) / knife.spinDur);
      const ease = p<0.5 ? 2*p*p : 1 - Math.pow(-2*p+2,2)/2; // easeInOutQuad
      // 360¬∞ spin around Y + slight flourish on Z
      knife.group.rotation.y = knife.baseRot.y + ease * Math.PI * 2;
      knife.group.rotation.z = knife.baseRot.z + Math.sin(ease*Math.PI)*0.25;
      if (p >= 1){
        knife.spin = false;
        knife.group.rotation.copy(knife.baseRot);
      }
    }
  }

  /* ========= Helpers: spawn position & grace ========= */
  function setStartPosition(){
    const radius = (trackInner + ARENA_RADIUS) * 0.5;
    const theta = Math.PI * 1.5; // bottom
    const x = Math.cos(theta) * radius;
    const z = Math.sin(theta) * radius;
    const player = cars[0];
    player.position.set(x, 0, z);
    player.rotationY = -theta;   // tangential direction
    player.mesh.position.set(x,0,z);
    player.mesh.rotation.y = player.rotationY;

    // reset followers
    while (cars.length > 1){ const seg = cars.pop(); scene.remove(seg.mesh); }

    // 2.5s grace
    spawnGraceUntil = performance.now() + 2500;
  }
  function canDie(){ return performance.now() >= spawnGraceUntil; }

  /* ========= Loop ========= */
  let lastTime = performance.now();
  const sessionStart = performance.now();

  function fmtTime(ms){
    const total = Math.floor(ms/1000);
    const m = Math.floor(total/60);
    const s = total % 60;
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  function animate(){
    requestAnimationFrame(animate);

    const now = performance.now();
    const dtRaw = (now - lastTime)/1000;
    const dt = Math.min(dtRaw, 0.05);
    lastTime = now;

    if (alive){
      const elapsed = now - gameStartMs;
      timerEl.textContent = fmtTime(elapsed);
    }

    const t = (now - sessionStart)/1000;
    const player = cars[0];

    // Speed scales with score
    const BASE_MIN   = isMobile ? 7 : 13;
    const BASE_MAX   = isMobile ? 26 : 42;
    const PER_POINT  = isMobile ? 0.35 : 0.6;
    let baseSpeed = BASE_MIN + score * PER_POINT;
    if (baseSpeed > BASE_MAX) baseSpeed = BASE_MAX;

    const ROTATION_SPEED = isMobile ? 2.5 : 3.5;

    if (alive){
      if (keys['a'] || keys['arrowleft']  || touchLeft)  player.rotationY += ROTATION_SPEED * dt;
      if (keys['d'] || keys['arrowright'] || touchRight) player.rotationY -= ROTATION_SPEED * dt;

      if ((keys[' '] && canBoost(player)) || player.boost.active){
        if (keys[' '] && canBoost(player)) startBoost(player);
      }
      updateBoost(player);

      const speed = baseSpeed * (player.boost.active ? BOOST_MULTIPLIER : 1);
      const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotationY);
      player.position.add(fwd.multiplyScalar(speed * dt));

      // followers
      for (let i=1;i<cars.length;i++){
        const lead = cars[i-1], foll = cars[i];
        const dir = new THREE.Vector3().subVectors(lead.position, foll.position);
        const dist = dir.length();
        if (dist > SEGMENT_DISTANCE){
          dir.normalize();
          foll.position.add(dir.multiplyScalar(Math.min(dist-SEGMENT_DISTANCE, speed*dt*1.5)));
        }
        const targetRot = Math.atan2(dir.x, dir.z);
        foll.rotationY += (targetRot - foll.rotationY) * 0.15;
      }

      // apply transforms
      for (let i=0;i<cars.length;i++){
        const c = cars[i];
        c.mesh.position.copy(c.position).setY(0);
        c.mesh.rotation.y = c.rotationY;
      }

      // animate pickups (bobbing + spin)
      for (const p of pickups){
        const y = p.baseY + Math.sin(t*2 + p.phase)*0.3 + 0.8;
        p.mesh.position.y = y;
        p.mesh.rotation.y += 0.02;
      }

      // pickups collection
      for (let i=pickups.length-1; i>=0; i--){
        if (pickups[i].mesh.position.distanceTo(player.position) < 3){
          scene.remove(pickups[i].mesh); pickups.splice(i,1);
          score++; scoreEl.textContent = score;
          addFollower(); spawnPickup();
        }
      }

      // moving barriers start after score >= 8
      const moveFactor = Math.min(1, Math.max(0, (score - 8) / 12));
      if (moveFactor > 0){
        for (const o of obstacles){
          const amp = o.amp * moveFactor;
          const w = o.freq;
          if (o.mode === 'circle'){
            o.mesh.position.x = o.base.x + Math.cos(w*t + o.phase) * amp;
            o.mesh.position.z = o.base.z + Math.sin(w*t + o.phase) * amp;
          } else {
            const s = Math.sin(w*t + o.phase) * amp;
            o.mesh.position.copy(o.base.clone().add(o.dir.clone().multiplyScalar(s)));
          }
          o.mesh.rotation.y += 0.4 * dt * moveFactor;
        }
      } else {
        for (const o of obstacles){ o.mesh.position.copy(o.base); }
      }

      // collisions & outer boundary (after grace)
      if (canDie()){
        for (const o of obstacles){
          if (o.mesh.position.distanceTo(player.position) < 4.0){
            doGameOver(); break;
          }
        }
        if (player.position.length() > ARENA_RADIUS-1.5){
          doGameOver();
        }
      }
    }

    // viewmodel updates
    updateKnife(dt);

    // camera follow
    const camOffset = new THREE.Vector3(0, 15, -30).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotationY);
    camera.position.copy(player.position.clone().add(camOffset));
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  function doGameOver(){
    if (!alive) return;
    alive = false;
    scoreEl.textContent = score;
    if (!leaderboardSubmitted){
      leaderboardSubmitted = true;
      submitScore(playerName || 'Player', score);
    }
    document.getElementById('finalScore').textContent = score;
    restartNameInput.value = playerName || '';
    restartOverlay.style.display = 'grid';
  }

  /* ========= Start / Restart ========= */
  startBtn.addEventListener('click', () => {
    const nm = (nameInput.value || '').trim().substring(0,20);
    if (!nm){ nameInput.focus(); return; }
    playerName = nm; localStorage.setItem('f1snake_name', playerName);
    score = 0; scoreEl.textContent = '0'; leaderboardSubmitted = false;
    setStartPosition();
    gameStartMs = performance.now();
    timerEl.textContent = '00:00';
    chatBox.style.display = 'flex';
    startOverlay.style.display = 'none';
    alive = true;
    if (!knife.group) addKnifeToCamera(); // always visible once game starts
  });
  nameInput.addEventListener('keydown', e=>{ if (e.key==='Enter') startBtn.click(); });

  restartBtn.addEventListener('click', () => {
    const nm = (restartNameInput.value || '').trim().substring(0,20);
    playerName = nm || playerName || 'Player';
    localStorage.setItem('f1snake_name', playerName);
    score = 0; scoreEl.textContent = '0'; leaderboardSubmitted = false;
    setStartPosition();
    gameStartMs = performance.now();
    timerEl.textContent = '00:00';
    for (const o of obstacles){ o.mesh.position.copy(o.base); }
    restartOverlay.style.display = 'none';
    alive = true;
    if (!knife.group) addKnifeToCamera();
  });

  // Start listeners/render
  startChatListener();
  animate();

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
})();
</script>
</body>
</html>
