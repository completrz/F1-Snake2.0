<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>F1 Snake ‚Äî Leaderboard + Chat + Ranks + RR + 2x XP + Middle Obstacles</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  :root{
    --glass: rgba(0,0,0,0.35);
    --panel: rgba(0,0,0,0.75);
    --accent: #00e5ff;
    --good: #3ae374;
    --bad: #ff4d6d;
  }
  html, body {
    margin: 0; height: 100%; overflow: hidden; background: #87b6ff;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: #fff;
    touch-action: none;
  }

  /* Left HUD */
  #hud {
    position: absolute; top: 14px; left: 14px; z-index: 30;
    background: var(--glass); padding: 10px 12px; border-radius: 12px;
    backdrop-filter: blur(6px); width: 300px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }
  #scoreRow { font-weight: 700; font-size: 18px; display:flex; justify-content:space-between; gap:8px; align-items:center; }
  #timer { font-variant-numeric: tabular-nums; opacity:.95; }
  #rankNow { font-size:12px; opacity:.95; display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;}
  #rankNow img{ width:18px; height:18px; vertical-align:middle; }
  #rankText { font-weight:700; }
  #rrText { padding:2px 6px; border-radius:8px; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12); font-variant-numeric:tabular-nums; }

  #hint   { margin-top: 6px; font-size: 12px; opacity: .85; line-height: 1.35; }

  /* 2x XP badge */
  #xpBadge{
    margin-top:8px; display:none; align-items:center; gap:8px; font-size:12px; font-weight:800;
    background: rgba(0,229,255,0.15); border:1px solid rgba(0,229,255,0.35); padding:6px 8px; border-radius:10px;
  }
  #xpBadge .dot{ width:8px; height:8px; border-radius:50%; background:#00ffd9; box-shadow:0 0 10px #00ffd9; }
  #xpTime{ font-variant-numeric: tabular-nums; }

  /* Chat (square, under instructions, left) */
  #chat {
    margin-top: 10px;
    width: 300px; height: 260px;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    display: none;            /* shown after name entered */
    flex-direction: column;
    overflow: hidden;
  }
  #chatHeader{
    padding: 8px 10px; font-size: 12px; letter-spacing:.2px; opacity:.9;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  #chatMessages {
    flex: 1; overflow-y: auto; padding: 8px 10px; line-height: 1.35; font-size: 13px;
  }
  #chatInput {
    border: none; outline: none; padding: 10px;
    background: #141920; color: #fff; font-size: 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
  }
  #chatInput::placeholder{ color:#8aa0b4; }

  /* Right column (leaderboard) */
  #rightCol{
    position: absolute; top: 14px; right: 14px; z-index: 30;
    width: 340px; display:flex; flex-direction:column; gap: 12px;
  }
  #leaderboard {
    width: 100%; max-height: 420px; overflow-y: auto;
    background: var(--panel); border: 1px solid rgba(255,255,255,0.08);
    border-radius: 14px; box-shadow: 0 6px 22px rgba(0,0,0,0.45);
    backdrop-filter: blur(6px);
  }
  #lbHeader{
    padding: 10px 14px; border-bottom: 1px solid rgba(255,255,255,0.08);
    display:flex; align-items:center; gap:8px;
  }
  #lbHeader .dot{ width:8px; height:8px; border-radius:50%; background: var(--accent); box-shadow:0 0 10px var(--accent); }
  #lbHeader h3{ margin:0; font-size: 14px; letter-spacing:.3px; font-weight: 700; }
  #lbList{ list-style:none; margin:0; padding: 8px 10px 12px 10px; }
  #lbList li{
    display:flex; justify-content: space-between; align-items:center;
    padding: 8px 8px; margin: 4px 0;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px; font-size: 14px; gap:8px;
  }
  .lb-left{ display:flex; align-items:center; gap:8px; min-width:0; }
  .rankIcon{ width:18px; height:18px; flex:0 0 18px; }
  #lbList li .rank{
    width: 22px; height: 22px; border-radius: 6px; display:flex; align-items:center; justify-content:center;
    background: rgba(255,255,255,0.08); font-size: 12px; margin-right: 4px; flex:0 0 22px;
  }
  #lbList li .name{ flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width:0; }
  #lbList li .score{ font-weight: 700; color: #b7f; }

  /* Overlays (start/restart) */
  .overlay {
    position: fixed; inset: 0; display: none; place-items: center; z-index: 50;
    background: radial-gradient(60% 60% at 50% 50%, rgba(0,229,255,0.08), rgba(0,0,0,0.55));
    animation: fadeIn .25s ease-out both;
  }
  @keyframes fadeIn { from{opacity:0} to{opacity:1} }
  .panel {
    width: min(560px, 92vw);
    background: rgba(10,14,20,.85);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    padding: 22px 22px 18px;
    text-align: center; backdrop-filter: blur(10px);
  }
  .title { font-weight: 800; font-size: 28px; letter-spacing:.3px; margin: 4px 0 6px; }
  .subtitle { opacity:.85; font-size: 14px; margin-bottom: 14px; }
  .inputRow { display:flex; gap:10px; justify-content:center; margin-top: 8px; }
  .textInput {
    width: 260px; padding: 10px 12px; border-radius: 10px; border:1px solid rgba(255,255,255,.12);
    outline:none; background:#0f1620; color:#fff; font-size:15px;
  }
  .btn {
    padding: 10px 16px; border-radius: 10px; border: none; cursor: pointer;
    background: linear-gradient(90deg, #00c6ff, #0072ff); color:#001318; font-weight: 800;
    text-transform: uppercase; letter-spacing:.4px;
    box-shadow: 0 10px 24px rgba(0,114,255,.35);
  }
  .btn:hover{ filter: brightness(1.07); }
  .small { font-size:12px; opacity:.8; margin-top:10px; }
  .scoreBadge{
    display:inline-block; padding: 6px 10px; border-radius: 999px;
    background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12);
    margin-bottom: 8px; font-weight:700;
  }
  /* RR summary on restart */
  #rrSummary { margin-top: 10px; font-size: 14px; }
  #rrDelta { font-weight:800; }
  #rrDelta.good{ color: var(--good); }
  #rrDelta.bad{ color: var(--bad); }

  /* Rank-up animation */
  #rankUpOverlay{
    position:fixed; inset:0; display:none; place-items:center; z-index:60;
    background: radial-gradient(40% 40% at 50% 50%, rgba(255,255,255,0.06), rgba(0,0,0,0.8));
  }
  #rankUpCard{
    display:flex; flex-direction:column; align-items:center; gap:12px;
    background: rgba(12,18,28,0.85);
    border: 1px solid rgba(255,255,255,0.14);
    padding: 22px 26px; border-radius: 16px;
    box-shadow: 0 30px 80px rgba(0,0,0,0.6);
    animation: pup .6s ease-out both;
  }
  @keyframes pup{ from{ transform: scale(.6); opacity:0 } to{ transform: scale(1); opacity:1 } }
  #rankUpBadge{ width:100px; height:100px; filter: drop-shadow(0 0 18px rgba(255,255,255,0.4)); }
  #rankUpText{ font-weight:900; letter-spacing:.4px; }
  .burst{
    position:absolute; width:6px; height:6px; border-radius:50%;
    background:#fff; opacity:.9; pointer-events:none; animation: fly 800ms ease-out forwards;
  }
  @keyframes fly{
    to{ transform: translate(var(--dx), var(--dy)) scale(0.2); opacity:0; }
  }
</style>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
</head>
<body>

<!-- Left HUD -->
<div id="hud">
  <div id="scoreRow">
    <span>Score: <span id="score">0</span></span>
    <span id="timer">00:00</span>
  </div>
  <div id="rankNow">
    <img id="rankNowIcon" alt="" />
    <span id="rankText">Rank: ‚Äî</span>
    <span id="rrText">RR: ‚Äî</span>
  </div>
  <div id="xpBadge"><span class="dot"></span> 2√ó XP active ‚Äî <span id="xpTime">00.0s</span></div>
  <div id="hint">Controls: A/D or ‚óÄÔ∏è/‚ñ∂Ô∏è ‚Ä¢ Touch left/right ‚Ä¢ Double-tap/2-finger = Boost ‚Ä¢ Press <b>F</b> to spin, <b>V</b> to inspect</div>

  <div id="chat">
    <div id="chatHeader">üí¨ Global Chat</div>
    <div id="chatMessages"></div>
    <input id="chatInput" placeholder="Type & press Enter" autocomplete="off" />
  </div>
</div>

<!-- Right column -->
<div id="rightCol">
  <div id="leaderboard">
    <div id="lbHeader"><span class="dot"></span><h3>Top 10 ‚Äî Global Leaderboard</h3></div>
    <ul id="lbList"><li><div class="lb-left"><span class="rank">‚Äì</span><img class="rankIcon" alt="" /><span class="name">Loading‚Ä¶</span></div><span class="score">‚Äì</span></li></ul>
  </div>
</div>

<!-- Start overlay -->
<div id="startOverlay" class="overlay" style="display:grid;">
  <div class="panel">
    <div class="title">F1 Snake</div>
    <div class="subtitle">Collect fuel cells anywhere in the arena. Avoid barriers. Boost wisely!</div>
    <div class="inputRow">
      <input id="nameInput" class="textInput" maxlength="20" placeholder="Player name" />
      <button id="startBtn" class="btn">Start</button>
    </div>
    <div class="small">Your last name is remembered on this device.</div>
  </div>
</div>

<!-- Restart overlay -->
<div id="restartOverlay" class="overlay">
  <div class="panel">
    <div class="title">Game Over</div>
    <div class="scoreBadge">Final Score: <span id="finalScore">0</span></div>

    <div id="rrSummary">
      <div id="rrLine1">Previous: <span id="prevRank">‚Äî</span> ‚Ä¢ <span id="prevRR">RR ‚Äî</span></div>
      <div id="rrLine2">Now: <span id="nowRank">‚Äî</span> ‚Ä¢ <span id="nowRR">RR ‚Äî</span> ‚Ä¢ <span id="rrDelta" class="">(+0 RR)</span></div>
      <div id="promoNote" style="margin-top:6px; font-weight:700;"></div>
    </div>

    <div class="inputRow" style="margin-top:12px;">
      <input id="restartNameInput" class="textInput" maxlength="20" placeholder="Player name" />
      <button id="restartBtn" class="btn">Restart</button>
    </div>
    <div class="small">Change your name or keep it the same.</div>
  </div>
</div>

<!-- Rank-up animation overlay -->
<div id="rankUpOverlay">
  <div id="rankUpCard">
    <img id="rankUpBadge" alt="">
    <div id="rankUpText">RANK UP!</div>
  </div>
</div>

<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script>
(() => {
  /* ========= Firebase ========= */
  const firebaseConfig = {
    apiKey: "AIzaSyC5seSlgxk4mCRn4HKet4rHlzhQVVBxc-8",
    authDomain: "f1-snake.firebaseapp.com",
    projectId: "f1-snake",
    storageBucket: "f1-snake.firebasestorage.app",
    messagingSenderId: "575341092161",
    appId: "1:575341092161:web:b9050e1df88c9e36de95c0"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  /* ========= DOM ========= */
  const startOverlay = document.getElementById('startOverlay');
  const restartOverlay = document.getElementById('restartOverlay');
  const nameInput = document.getElementById('nameInput');
  const startBtn = document.getElementById('startBtn');
  const restartNameInput = document.getElementById('restartNameInput');
  const restartBtn = document.getElementById('restartBtn');
  const scoreEl = document.getElementById('score');
  const timerEl = document.getElementById('timer');
  const chatBox = document.getElementById('chat');
  const chatMessagesEl = document.getElementById('chatMessages');
  const chatInputEl = document.getElementById('chatInput');
  const lbList = document.getElementById('lbList');

  const rankNowIcon = document.getElementById('rankNowIcon');
  const rankText = document.getElementById('rankText');
  const rrText = document.getElementById('rrText');

  const prevRankEl = document.getElementById('prevRank');
  const prevRREl = document.getElementById('prevRR');
  const nowRankEl = document.getElementById('nowRank');
  const nowRREl = document.getElementById('nowRR');
  const rrDeltaEl = document.getElementById('rrDelta');
  const promoNoteEl = document.getElementById('promoNote');

  const rankUpOverlay = document.getElementById('rankUpOverlay');
  const rankUpBadge = document.getElementById('rankUpBadge');
  const rankUpText = document.getElementById('rankUpText');

  const xpBadge = document.getElementById('xpBadge');
  const xpTime = document.getElementById('xpTime');

  /* ========= State ========= */
  let playerName = localStorage.getItem('f1snake_name') || '';
  if (playerName) { nameInput.value = playerName; }
  let alive = false;
  let score = 0;
  let gameStartMs = 0;
  let spawnGraceUntil = 0;

  // Rank snapshot for RR delta calculation
  let prevRankIndex = 0;
  let prevRR = 0;

  // XP Multiplier
  let xpMultActive = false;
  let xpMultUntil = 0;
  const XP_DURATION_MS = 15000;

  /* ========= Ranks ========= */
  const RANKS = [
    'Iron 1','Iron 2','Iron 3',
    'Bronze 1','Bronze 2','Bronze 3',
    'Silver 1','Silver 2','Silver 3',
    'Gold 1','Gold 2','Gold 3',
    'Platinum 1','Platinum 2','Platinum 3',
    'Diamond 1','Diamond 2','Diamond 3',
    'Ascendant 1','Ascendant 2','Ascendant 3',
    'Immortal 1','Immortal 2','Immortal 3',
    'Radiant'
  ];
  const RADIANT_INDEX = RANKS.length - 1;
  function rankGroup(idx){
    if (idx === RADIANT_INDEX) return 'Radiant';
    const groups = ['Iron','Bronze','Silver','Gold','Platinum','Diamond','Ascendant','Immortal'];
    return groups[Math.floor(idx/3)] || 'Radiant';
  }
  function sanitizeId(name){
    return (name||'player').trim().toLowerCase().replace(/[^a-z0-9_-]/g,'_');
  }
  function rankColor(idx){
    const g = rankGroup(idx);
    switch(g){
      case 'Iron': return '#8c8c8c';
      case 'Bronze': return '#b88650';
      case 'Silver': return '#b9c3cf';
      case 'Gold': return '#e7c14c';
      case 'Platinum': return '#3dd4c6';
      case 'Diamond': return '#66a5ff';
      case 'Ascendant': return '#4bd37d';
      case 'Immortal': return '#c15cff';
      case 'Radiant': return '#ffe75e';
      default: return '#999';
    }
  }
  let currentRankColor = rankColor(0);
  function rankBadgeDataURI(idx, big=false){
    const col = rankColor(idx);
    const size = big?120:18;
    const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 18 18">
  <defs>
    <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="${col}"/>
      <stop offset="1" stop-color="#111"/>
    </linearGradient>
    <filter id="s" x="-50%" y="-50%" width="200%" height="200%">
      <feDropShadow dx="0" dy="0" stdDeviation="0.8" flood-color="${col}" flood-opacity="0.6"/>
    </filter>
  </defs>
  <polygon points="9,1 16,6 13.8,16 4.2,16 2,6" fill="url(#g)" stroke="${col}" stroke-width="1" filter="url(#s)"/>
</svg>`;
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
  }

  /* ========= Economy ========= */
  const COINS_PER_POINT = 1;

  async function getOrCreatePlayerRank(name){
    const id = sanitizeId(name);
    const ref = db.collection('players').doc(id);
    const snap = await ref.get();
    if (!snap.exists){
      const data = { name, rankIndex: 0, rr: 0, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
      await ref.set(data);
      return data;
    }
    return snap.data();
  }

  function computeRRDelta(rankIndex, score, elapsedMs){
    const minutes = elapsedMs / 60000;
    const perf = score + Math.min(12, minutes * 1.2);
    const base = (perf - 6) * 9;
    const tierGroup = Math.min(7, Math.floor(rankIndex/3));
    const scale = 1 - Math.min(0.72, tierGroup * 0.08);
    let delta = Math.round(base * scale);

    if (score >= 20) delta += 12;
    if (score >= 35) delta += 16;
    if (score <= 1 && minutes < 0.4) delta -= 25;
    if (score === 0 && minutes < 0.25) delta -= 35;

    if (rankIndex <= 5 && delta < 0) delta = Math.max(delta, -18);
    delta = Math.max(-45, Math.min(70, delta));
    return delta;
  }

  // Radiant-uncapped HUD
  function setHudRank(idx, rrVal){
    rankNowIcon.src = rankBadgeDataURI(idx);
    rankText.textContent = `Rank: ${RANKS[idx] || 'Unrated'}`;
    const rr = Math.round(rrVal ?? 0);
    if (idx === RADIANT_INDEX){
      rrText.textContent = `Radiant RR: ${rr}`;
    } else {
      rrText.textContent = `RR: ${Math.max(0, Math.min(100, rr))}`;
    }
    setCarColor(rankColor(idx));
  }

  // Save RR using name-based doc id
  async function applyMatchResultAndSave(name, scoreVal, elapsedMs){
    const id = sanitizeId(name);
    const ref = db.collection('players').doc(id);
    const data = (await ref.get()).data() || { rankIndex:0, rr:0 };

    let idx = data.rankIndex || 0;
    let rr  = data.rr || 0;

    let delta = computeRRDelta(idx, scoreVal, elapsedMs);
    if (idx === RADIANT_INDEX){
      const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
      delta = clamp(Math.round(delta * 0.5), -40, 40); // Radiant damping
    }
    rr += delta;

    let promos = 0, deranks = 0;
    while (rr >= 100 && idx < RADIANT_INDEX){ rr -= 100; idx++; promos++; }
    while (rr < 0 && idx > 0){ rr += 100; idx--; deranks++; }
    if (idx === 0 && rr < 0) rr = 0;

    await ref.set({
      name,
      rankIndex: idx,
      rr,
      coins: (data.coins||0) + (scoreVal * COINS_PER_POINT),
      highScore: Math.max(data.highScore||0, scoreVal||0),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge:true });

    return { rankIndex: idx, rr, delta, promos, deranks };
  }

  // Prevent future duplicates: write one doc per user (id = sanitized name) and keep highest score
  async function upsertHighScore(name, scoreVal, rankIndex){
    const id = sanitizeId(name);
    const ref = db.collection('leaderboard').doc(id);
    try{
      await db.runTransaction(async (tx)=>{
        const snap = await tx.get(ref);
        if (!snap.exists){
          tx.set(ref, {
            name, score: scoreVal, rankIndex: rankIndex ?? 0,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        } else {
          const cur = snap.data();
          if ((cur.score||0) < scoreVal){
            tx.set(ref, {
              name, score: scoreVal, rankIndex: rankIndex ?? (cur.rankIndex||0),
              timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }, {merge:true});
          } else if (typeof rankIndex === 'number' && (cur.rankIndex||0)!==rankIndex){
            tx.set(ref, { rankIndex }, {merge:true});
          }
        }
      });
    }catch(e){ console.error('upsertHighScore failed', e); }
  }

  /* ========= Leaderboard (de-duplicate existing) ========= */
  function startLeaderboardListener(){
    db.collection('leaderboard').orderBy('score','desc').limit(100).onSnapshot(async snap=>{
      // Client-side collapse by name to handle old duplicate entries
      const byName = new Map();
      snap.forEach(doc=>{
        const d = doc.data();
        const key = sanitizeId(d.name||'Player');
        const existing = byName.get(key);
        if (!existing || (d.score||0) > existing.score){
          byName.set(key, {name: d.name||'Player', score: d.score||0, rankIndex: (typeof d.rankIndex==='number')? d.rankIndex : null});
        }
      });

      // Fetch missing rankIndex from players
      const items = Array.from(byName.values());
      for (let it of items){
        if (it.rankIndex === null){
          const ps = await db.collection('players').doc(sanitizeId(it.name)).get();
          it.rankIndex = ps.exists ? (ps.data().rankIndex||0) : 0;
        }
      }
      // Sort & take top 10
      items.sort((a,b)=> (b.score||0) - (a.score||0));
      const top = items.slice(0,10);

      // Render
      lbList.innerHTML = '';
      if (!top.length){
        const li = document.createElement('li');
        li.innerHTML = `<div class="lb-left"><span class="rank">‚Äì</span><img class="rankIcon" alt="" /><span class="name">No scores yet</span></div><span class="score">‚Äì</span>`;
        lbList.appendChild(li);
        return;
      }
      let pos = 1;
      for (const it of top){
        const li = document.createElement('li');
        const left = document.createElement('div');
        left.className = 'lb-left';
        const rankSpan = document.createElement('span');
        rankSpan.className = 'rank'; rankSpan.textContent = pos;
        const img = document.createElement('img');
        img.className = 'rankIcon'; img.src = rankBadgeDataURI(it.rankIndex||0); img.alt = '';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'name'; nameSpan.textContent = it.name;

        left.appendChild(rankSpan); left.appendChild(img); left.appendChild(nameSpan);
        const scoreSpan = document.createElement('span'); scoreSpan.className = 'score'; scoreSpan.textContent = it.score;

        li.appendChild(left); li.appendChild(scoreSpan); lbList.appendChild(li);
        pos++;
      }
    });
  }
  startLeaderboardListener();

  /* ========= Chat (last 50) ========= */
  const CHAT_MAX = 50;
  function startChatListener(){
    db.collection('chat').orderBy('timestamp','desc').limit(CHAT_MAX).onSnapshot(snap=>{
      const arr = []; snap.forEach(d=>arr.push(d.data())); arr.reverse();
      chatMessagesEl.innerHTML = '';
      arr.forEach(m=>{
        const time = m.timestamp ? new Date(m.timestamp.seconds*1000).toLocaleTimeString() : '';
        const div = document.createElement('div');
        div.textContent = `[${time}] ${m.name||'Player'}: ${m.message||''}`;
        chatMessagesEl.appendChild(div);
      });
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    });
  }
  async function sendMessage(text){
    const t = (text||'').trim(); if (!t) return;
    await db.collection('chat').add({
      name: playerName || 'Player',
      message: t,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });
    // Trim > 50
    const all = await db.collection('chat').orderBy('timestamp','asc').get();
    if (all.size > CHAT_MAX){
      const toDelete = all.docs.slice(0, all.size-CHAT_MAX);
      const batch = db.batch(); toDelete.forEach(doc=>batch.delete(doc.ref)); await batch.commit();
    }
  }
  chatInputEl.addEventListener('keydown', e=>{
    if (e.key === 'Enter'){ e.preventDefault(); sendMessage(chatInputEl.value); chatInputEl.value=''; }
  });

  /* ========= THREE / Scene ========= */
  const ARENA_RADIUS = 180;
  const TRACK_WIDTH = 34;
  const trackInner = ARENA_RADIUS - TRACK_WIDTH;

  const SEGMENT_DISTANCE = 6;
  const BOOST_MULTIPLIER = 2.4;
  const BOOST_DURATION = 2000;
  const BOOST_COOLDOWN = 4000;
  const OBSTACLE_COUNT = 36; // a bit more
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x9cc6ff, 0.0009);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.5, 2000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  /* ---------- Sky Dome ---------- */
  function makeSkyDome(){
    const c = document.createElement('canvas');
    c.width = 2; c.height = 256;
    const ctx = c.getContext('2d');
    const grd = ctx.createLinearGradient(0,0,0,256);
    grd.addColorStop(0,   '#83b8ff');
    grd.addColorStop(0.6, '#a9ccff');
    grd.addColorStop(1,   '#d8e8ff');
    ctx.fillStyle = grd; ctx.fillRect(0,0,2,256);
    const tex = new THREE.CanvasTexture(c);
    tex.magFilter = THREE.LinearFilter;
    const geo = new THREE.SphereGeometry(1500, 32, 16);
    const mat = new THREE.MeshBasicMaterial({map: tex, side: THREE.BackSide});
    return new THREE.Mesh(geo, mat);
  }
  scene.add(makeSkyDome());

  /* ---------- Lights ---------- */
  const hemiLight = new THREE.HemisphereLight(0xcfe3ff, 0x8fb3d9, 0.6);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(60, 120, 40);
  scene.add(dirLight);

  /* ---------- Track / Ground ---------- */
  const grass = new THREE.Mesh(
    new THREE.CircleGeometry(ARENA_RADIUS, 128),
    new THREE.MeshStandardMaterial({color:0x7bbf5d, roughness:0.95, metalness:0.0})
  );
  grass.rotation.x = -Math.PI/2;
  grass.receiveShadow = true;
  scene.add(grass);

  const asphalt = new THREE.Mesh(
    new THREE.RingGeometry(trackInner, ARENA_RADIUS, 256),
    new THREE.MeshStandardMaterial({color:0x2f3238, roughness:0.95, metalness:0.0})
  );
  asphalt.rotation.x = -Math.PI/2;
  asphalt.position.y = 0.01;
  scene.add(asphalt);

  function curbTexture(){
    const c = document.createElement('canvas');
    c.width = 512; c.height = 16;
    const ctx = c.getContext('2d');
    const stripeW = 32;
    for(let x=0;x<c.width;x+=stripeW){
      ctx.fillStyle = (Math.floor(x/stripeW)%2===0)?'#ffffff':'#d10';
      ctx.fillRect(x,0,stripeW,c.height);
    }
    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.repeat.set(4,1);
    return tex;
  }
  const curbMatOuter = new THREE.MeshBasicMaterial({map: curbTexture(), side: THREE.DoubleSide});
  const curbMatInner = new THREE.MeshBasicMaterial({map: curbTexture(), side: THREE.DoubleSide});
  const curbOuter = new THREE.Mesh(new THREE.RingGeometry(ARENA_RADIUS-1.5, ARENA_RADIUS-0.2, 256), curbMatOuter);
  curbOuter.rotation.x = -Math.PI/2; curbOuter.position.y = 0.015; scene.add(curbOuter);
  const curbInner = new THREE.Mesh(new THREE.RingGeometry(trackInner+0.2, trackInner+1.5, 256), curbMatInner);
  curbInner.rotation.x = -Math.PI/2; curbInner.position.y = 0.015; scene.add(curbInner);

  /* ---------- Start grid decal ---------- */
  function makeCheckeredTile(){
    const c = document.createElement('canvas');
    c.width = c.height = 128;
    const ctx = c.getContext('2d');
    for(let y=0;y<8;y++){
      for(let x=0;x<8;x++){
        ctx.fillStyle = ((x+y)%2===0) ? '#111' : '#eee';
        ctx.fillRect(x*16,y*16,16,16);
      }
    }
    return new THREE.CanvasTexture(c);
  }
  const gridMat = new THREE.MeshBasicMaterial({ map: makeCheckeredTile(), transparent:true, opacity:0.75 });
  const gridMesh = new THREE.Mesh(new THREE.PlaneGeometry(12,6), gridMat);
  gridMesh.rotation.x = -Math.PI/2;
  gridMesh.position.set(0,0.02, -ARENA_RADIUS + 14);
  scene.add(gridMesh);

  /* ---------- Car Models ---------- */
  function makeHeadCar(primary=0xff2d55, accent=0xffffff){
    const g = new THREE.Group();
    const wheelMat = new THREE.MeshStandardMaterial({color:0x111111, metalness:.3, roughness:.6});
    const wheelGeo = new THREE.CylinderGeometry(0.6,0.6,0.4,16);
    const wheels = [0,1,2,3].map(()=>new THREE.Mesh(wheelGeo, wheelMat));
    wheels.forEach(w=>{ w.rotation.z = Math.PI/2; w.castShadow = true; w.receiveShadow=true; g.add(w); });
    wheels[0].position.set(-1.2, 0.6,  2.2);
    wheels[1].position.set( 1.2, 0.6,  2.2);
    wheels[2].position.set(-1.2, 0.6, -2.0);
    wheels[3].position.set( 1.2, 0.6, -2.0);
    const bodyMat = new THREE.MeshStandardMaterial({color:primary, metalness:.5, roughness:.3});
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.6,5.6), bodyMat);
    body.position.set(0, 0.9, 0); body.castShadow = true; g.add(body);
    const pod = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,3.6), bodyMat);
    const pod2 = pod.clone(); pod.position.set(-1.4, 0.85, 0); pod2.position.set(1.4, 0.85, 0); g.add(pod); g.add(pod2);
    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.0,0.5,1.2),
      new THREE.MeshStandardMaterial({color:accent, metalness:.2, roughness:.6}));
    cockpit.position.set(0, 1.25, 1.0); cockpit.castShadow = true; g.add(cockpit);
    const fwing = new THREE.Mesh(new THREE.BoxGeometry(3.2,0.15,0.9), bodyMat); fwing.position.set(0, 0.75, 3.1); g.add(fwing);
    const rwing = new THREE.Mesh(new THREE.BoxGeometry(2.4,0.15,0.6), bodyMat); rwing.position.set(0, 1.15, -2.8); g.add(rwing);
    const rwingVert = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.7,0.05), bodyMat); rwingVert.position.set(0, 1.0, -2.6); g.add(rwingVert);
    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.5,1.2,14), bodyMat); nose.rotation.x = Math.PI; nose.position.set(0,0.95,3.5); g.add(nose);
    g.userData.colorMats = [bodyMat];
    return g;
  }
  function makeTailCar(primary=0xff8a00, trim=0x333333){
    const g = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({color:primary, metalness:.4, roughness:.4});
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.5,4.2), bodyMat);
    body.position.set(0,0.85,0); g.add(body);
    const bump = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.35,0.9),
      new THREE.MeshStandardMaterial({color:0xffffff, metalness:.2, roughness:.6}));
    bump.position.set(0,1.1,0.6); g.add(bump);
    const wing = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.12,0.45), bodyMat);
    wing.position.set(0,1.05,-2.1); g.add(wing);
    const wheelMat = new THREE.MeshStandardMaterial({color:trim, metalness:.3, roughness:.6});
    const wheelGeo = new THREE.CylinderGeometry(0.5,0.5,0.3,14);
    const w1 = new THREE.Mesh(wheelGeo, wheelMat), w2 = new THREE.Mesh(wheelGeo, wheelMat);
    w1.rotation.z = Math.PI/2; w2.rotation.z = Math.PI/2;
    w1.position.set(-1.1,0.6,0.8); w2.position.set(1.1,0.6,0.8); g.add(w1); g.add(w2);
    g.userData.colorMats = [bodyMat];
    return g;
  }

  // Cars
  const cars = [];
  function setCarColor(color){
    currentRankColor = color;
    for (const c of cars){
      const mats = c.mesh.userData && c.mesh.userData.colorMats;
      if (mats){ mats.forEach(m=>m.color.set(color)); }
    }
  }
  cars.push({
    position: new THREE.Vector3(0,0,0),
    rotationY: 0,
    mesh: makeHeadCar(currentRankColor, 0xbfd8ff),
    boost: {active:false, cooldown:0, timer:0}
  });
  scene.add(cars[0].mesh);
  cars[0].mesh.position.set(0,0,0);

  function addFollower(){
    const leader = cars[cars.length-1];
    const follower = {
      position: new THREE.Vector3().copy(leader.position),
      rotationY: leader.rotationY,
      mesh: makeTailCar(currentRankColor, 0x222222),
    };
    const back = new THREE.Vector3(0,0,-SEGMENT_DISTANCE).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotationY);
    follower.position.add(back);
    scene.add(follower.mesh);
    cars.push(follower);
  }

  /* ---------- Pickups ---------- */
  const pickups = [];
  function createFuelCell(){
    const group = new THREE.Group();
    const core = new THREE.Mesh(
      new THREE.IcosahedronGeometry(1.0, 0),
      new THREE.MeshStandardMaterial({color:0x00ffae, emissive:0x00ffae, emissiveIntensity:0.6, roughness:0.3, metalness:0.2})
    );
    core.position.y = 1.0;
    group.add(core);
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(1.2, 0.06, 12, 40),
      new THREE.MeshBasicMaterial({color:0x66ffd9, transparent:true, opacity:0.6})
    );
    ring.rotation.x = Math.PI/2; ring.position.y = 1.0; group.add(ring);
    return group;
  }
  function randomPointInCircle(minR=4, maxR=ARENA_RADIUS*.7){
    const u = Math.random();
    // sqrt(u) makes uniform area; tweak bias toward center by using linear u (more central)
    const bias = 0.35; // 0..1, higher = more central
    const rU = bias*u + (1-bias)*Math.sqrt(u);
    const r = rU * (maxR - minR) + minR;
    const a = Math.random() * Math.PI * 2;
    return new THREE.Vector3(Math.cos(a)*r, 0, Math.sin(a)*r);
  }
  function spawnPickup(){
    const p = createFuelCell();
    const pos = randomPointInCircle(6, ARENA_RADIUS - 6);
    p.position.copy(pos);
    scene.add(p);
    pickups.push({mesh:p, baseY:0, phase: Math.random()*Math.PI*2});
  }
  for(let i=0;i<10;i++) spawnPickup();

  /* ---------- 2x XP Gems ---------- */
  const xpGems = [];
  function makeGem(){
    const g = new THREE.Group();
    const core = new THREE.Mesh(
      new THREE.OctahedronGeometry(1.0, 1),
      new THREE.MeshStandardMaterial({color:0x57a0ff, emissive:0x5fb0ff, emissiveIntensity:0.8, metalness:0.2, roughness:0.4})
    );
    core.position.y = 1.1; g.add(core);
    const halo = new THREE.Mesh(
      new THREE.TorusGeometry(1.4, 0.07, 10, 40),
      new THREE.MeshBasicMaterial({color:0x9bd1ff, transparent:true, opacity:0.55})
    );
    halo.rotation.x = Math.PI/2; halo.position.y = 1.1; g.add(halo);
    return g;
  }
  function spawnGem(){
    const gem = makeGem();
    // bias to middle area (inner half)
    const pos = randomPointInCircle(4, ARENA_RADIUS * 0.55);
    gem.position.copy(pos);
    scene.add(gem);
    xpGems.push({mesh:gem, phase:Math.random()*Math.PI*2});
  }
  // keep up to 2 gems on field
  function maintainGems(){
    if (xpGems.length < 2 && Math.random() < 0.01) spawnGem();
  }

  /* ---------- Obstacles (more in middle) ---------- */
  const obstacles = [];
  const barrelMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    map: (()=>{ const c=document.createElement('canvas'); c.width=128; c.height=64;
      const ctx=c.getContext('2d'); for(let i=0;i<6;i++){ ctx.fillStyle=(i%2===0)?'#d10':'#fff'; ctx.fillRect(0,i*(c.height/6),c.width,(c.height/6)); }
      const t = new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; return t; })(),
    metalness: 0.2, roughness: 0.7
  });
  function makeBarrier(){
    const g = new THREE.Group();
    const cyl = new THREE.Mesh(new THREE.CylinderGeometry(2,2,4,24,1,true), barrelMat);
    cyl.position.y = 2; g.add(cyl);
    const capMat = new THREE.MeshStandardMaterial({color:0x2f3238, metalness:0.2, roughness:0.6});
    const capTop = new THREE.Mesh(new THREE.CircleGeometry(2,24), capMat);
    capTop.rotation.x = -Math.PI/2; capTop.position.y = 4; g.add(capTop);
    const capBottom = new THREE.Mesh(new THREE.CircleGeometry(2,24), capMat);
    capBottom.rotation.x =  Math.PI/2; capBottom.position.y = 0; g.add(capBottom);
    const light = new THREE.Mesh(new THREE.SphereGeometry(0.25,12,12), new THREE.MeshStandardMaterial({color:0xff4040, emissive:0xff4040, emissiveIntensity:1.2}));
    light.position.set(0,4.4,0); g.add(light);
    return g;
  }
  function spawnObstacles(){
    const middleCount = Math.floor(OBSTACLE_COUNT * 0.6);
    const outerCount  = OBSTACLE_COUNT - middleCount;

    // Middle-biased obstacles (inner area)
    for(let i=0;i<middleCount;i++){
      const pos = randomPointInCircle(6, ARENA_RADIUS * 0.6); // inner 60%
      const b = makeBarrier(); b.position.copy(pos); scene.add(b);
      const mode = (i % 2 === 0) ? 'circle' : 'bounce';
      const amp = THREE.MathUtils.randFloat(4, 9); // smaller paths in middle
      const freq = THREE.MathUtils.randFloat(0.18, 0.5);
      const phase = Math.random() * Math.PI * 2;
      let dir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5);
      if (dir.lengthSq() < 0.01) dir.set(1,0,0); dir.normalize();
      obstacles.push({ mesh:b, base: b.position.clone(), mode, amp, freq, phase, dir });
    }
    // General obstacles (anywhere except extreme border)
    for(let i=0;i<outerCount;i++){
      const pos = randomPointInCircle(10, ARENA_RADIUS - 12);
      const b = makeBarrier(); b.position.copy(pos); scene.add(b);
      const mode = (i % 2 === 0) ? 'circle' : 'bounce';
      const amp = THREE.MathUtils.randFloat(6, 12);
      const freq = THREE.MathUtils.randFloat(0.15, 0.45);
      const phase = Math.random() * Math.PI * 2;
      let dir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5);
      if (dir.lengthSq() < 0.01) dir.set(1,0,0); dir.normalize();
      obstacles.push({ mesh:b, base: b.position.clone(), mode, amp, freq, phase, dir });
    }
  }
  spawnObstacles();

  /* ---------- INPUT ---------- */
  const keys = {};
  window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup',   e=> keys[e.key.toLowerCase()] = false);

  let touchLeft=false, touchRight=false, lastTap=0;
  function handleTouchStart(e){
    e.preventDefault();
    if (e.touches.length===1){
      const x = e.touches[0].clientX;
      (x < innerWidth/2) ? touchLeft=true : touchRight=true;
    } else if (e.touches.length===2){
      if (canBoost(cars[0])) startBoost(cars[0]);
    }
  }
  function handleTouchEnd(e){ e.preventDefault(); touchLeft=false; touchRight=false; }
  function handleTap(){
    const now = Date.now();
    if (now - lastTap < 300){ if (canBoost(cars[0])) startBoost(cars[0]); }
    lastTap = now;
  }
  window.addEventListener('touchstart', handleTouchStart, {passive:false});
  window.addEventListener('touchend',   handleTouchEnd,   {passive:false});
  window.addEventListener('touchcancel',handleTouchEnd,   {passive:false});
  window.addEventListener('click', handleTap);

  function canBoost(car){
    const t = performance.now();
    if (car.boost.cooldown && t < car.boost.cooldown) return false;
    return true;
  }
  function startBoost(car){
    const t = performance.now();
    car.boost.active = true;
    car.boost.timer = t + BOOST_DURATION;
    car.boost.cooldown = t + BOOST_DURATION + BOOST_COOLDOWN;
  }
  function updateBoost(car){
    const t = performance.now();
    if (car.boost.active && t > car.boost.timer) car.boost.active = false;
  }

  /* ---------- FIRST-PERSON KNIFE (Prime Karambit 2.0) ---------- */
  const knife = {
    group:null,
    basePos:new THREE.Vector3(0.74,-0.58,-1.12),
    baseRot:new THREE.Euler(-0.18, 0.58, 0.26),
    spin:false, spinStart:0, spinDur:1100,
    inspect:false, inspectStart:0,
    trailPool:[],
  };

  function makeMatcap(colorHex, gloss=0.9, rough=0.22, emissive=0x000000, emissiveIntensity=0){
    return new THREE.MeshStandardMaterial({
      color: colorHex, metalness: gloss, roughness: rough,
      emissive, emissiveIntensity
    });
  }
  const MAT_GOLD    = makeMatcap(0xffd166, 1.0, 0.18, 0x3a2500, 0.07);
  const MAT_PEARL   = makeMatcap(0xe8ecf4, 1.0, 0.12);
  const MAT_EDGE    = makeMatcap(0xffffff, 1.0, 0.08);
  const MAT_PURPLE  = makeMatcap(0x6b4bff, 0.65, 0.35, 0x120a3a, 0.09);
  const MAT_GEM     = makeMatcap(0x00e5ff, 0.85, 0.2, 0x007a7a, 0.35);

  function makeSpineGlow(){
    const geo = new THREE.TubeGeometry(
      new THREE.CatmullRomCurve3(
        new Array(40).fill(0).map((_,i)=>{
          const t=i/39, a=t*Math.PI*1.08;
          return new THREE.Vector3( Math.cos(a)*0.86, Math.sin(a)*0.04, Math.sin(a)*0.04 );
        })
      ), 120, 0.015, 8, false
    );
    const mat = new THREE.MeshBasicMaterial({ color:0xffc53a, transparent:true, opacity:0.85 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = Math.PI/2;
    mesh.rotation.z = Math.PI/2.9 + 0.06;
    mesh.position.set(0.18, 0.0, 0.06);
    return mesh;
  }

  function makeEnergyRuneRing(){
    const ring = new THREE.Group();
    const outer = new THREE.Mesh(new THREE.TorusGeometry(0.195, 0.055, 16, 32), MAT_GOLD);
    outer.rotation.x = Math.PI/2; outer.position.set(-0.69, 0.02, -0.10); ring.add(outer);

    const gem = new THREE.Mesh(new THREE.IcosahedronGeometry(0.07, 1), MAT_GEM);
    gem.position.set(-0.69, 0.02, -0.10); ring.add(gem);

    // small orbiting runes
    for (let i=0;i<6;i++){
      const s = 0.018 + Math.random()*0.012;
      const r = new THREE.Mesh(new THREE.TorusGeometry(s*0.9, s*0.4, 6, 10), new THREE.MeshBasicMaterial({color:0xfff0b3}));
      r.userData.t = Math.random()*Math.PI*2;
      r.position.set(-0.69, 0.02, -0.10);
      ring.add(r);
    }
    ring.userData.animate = (t)=>{
      const kids = ring.children;
      for (let i=2;i<kids.length;i++){
        kids[i].userData.t += 0.02;
        const a = kids[i].userData.t + (i*0.6);
        kids[i].position.x = -0.69 + Math.cos(a)*0.11;
        kids[i].position.z = -0.10 + Math.sin(a)*0.11;
      }
      gem.rotation.x = t*0.8;
      gem.rotation.y = t*1.1;
    };
    return ring;
  }

  function makePrimeKarambit(){
    const g = new THREE.Group();
    // blade core
    const arc = Math.PI * 1.15;
    const blade = new THREE.Mesh(new THREE.TorusGeometry(0.9, 0.09, 26, 160, arc), MAT_PEARL);
    blade.rotation.x = Math.PI/2; blade.rotation.z = Math.PI/2.9; blade.position.set(0.18, 0.0, 0.06);
    g.add(blade);

    // keen edge overlay
    const edge = new THREE.Mesh(new THREE.TorusGeometry(0.9, 0.05, 14, 160, arc), MAT_EDGE);
    edge.rotation.copy(blade.rotation); edge.position.copy(blade.position); edge.scale.set(1.02,1.02,1.02);
    g.add(edge);

    // gold spine (thin) + animated glow tube
    const spine = new THREE.Mesh(new THREE.TorusGeometry(0.88, 0.022, 10, 120, arc*0.92), MAT_GOLD);
    spine.rotation.copy(blade.rotation); spine.position.copy(blade.position); spine.rotation.z += 0.06;
    g.add(spine);
    const glow = makeSpineGlow(); g.add(glow);

    // grip (angled) with purple ceramic wrap
    const grip = new THREE.Mesh(new THREE.CapsuleGeometry(0.11, 0.66, 10, 20), MAT_PURPLE);
    grip.rotation.z = Math.PI/6; grip.position.set(-0.42, -0.02, -0.06); g.add(grip);

    // pommel ring + gem + runes
    const ring = makeEnergyRuneRing(); g.add(ring);

    g.userData.animate = (t)=>{
      // subtle pulse along the spine glow
      glow.material.opacity = 0.72 + Math.sin(t*3.0)*0.12;
      // rune animation
      ring.userData.animate?.(t);
    };
    return g;
  }

  function spawnTrail(){
    // lightweight trail sprite when spinning
    const s = 0.22 + Math.random()*0.08;
    const geo = new THREE.PlaneGeometry(s, s*2.2);
    const mat = new THREE.MeshBasicMaterial({ color:0xffe08a, transparent:true, opacity:0.55, side:THREE.DoubleSide });
    const m = new THREE.Mesh(geo, mat);
    m.rotation.y = Math.random()*Math.PI*2;
    m.userData.life = 220; // ms
    knife.trailPool.push(m);
    camera.add(m);
    m.position.copy(knife.group.position.clone().add(new THREE.Vector3(-0.08, -0.02, -0.2)));
  }

  function attachKnifeToCamera(){
    if (knife.group) camera.remove(knife.group);
    knife.group = makePrimeKarambit();
    camera.add(knife.group);
    knife.group.position.copy(knife.basePos);
    knife.group.rotation.copy(knife.baseRot);
  }

  function startSpin(){
    if (!knife.group || knife.spin) return;
    knife.spin = true; knife.spinStart = performance.now();
  }
  function startInspect(){
    if (!knife.group || knife.inspect) return;
    knife.inspect = true; knife.inspectStart = performance.now();
  }

  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k === 'f') startSpin();     // quick spin
    if (k === 'v') startInspect();  // longer inspect
  });

  function updateKnife(){
    if (!knife.group) return;
    const t = performance.now()*0.001;

    // idle bob
    knife.group.position.y = knife.basePos.y + Math.sin(t*2.2)*0.01;
    knife.group.rotation.x = knife.baseRot.x + Math.sin(t*1.6)*0.01;

    // per-frame ornament animation
    knife.group.children.forEach(c=>c.userData?.animate?.(t));

    // spin
    if (knife.spin){
      const now = performance.now();
      const p = Math.min(1, (now - knife.spinStart)/knife.spinDur);
      const ease = (x)=>x<0.5?4*x*x*x:1-Math.pow(-2*x+2,3)/2;
      const a = ease(p) * Math.PI*2.2;
      knife.group.rotation.y = knife.baseRot.y + a;
      if (Math.random() < 0.25) spawnTrail();
      if (p >= 1){ knife.spin = false; }
    } else {
      knife.group.rotation.y = THREE.MathUtils.damp(knife.group.rotation.y, knife.baseRot.y, 8, 1/60);
    }

    // inspect (slow tilt + hold at edge)
    if (knife.inspect){
      const now = performance.now();
      const tSec = (now - knife.inspectStart)/1000;
      const swing = Math.min(1, tSec/0.35);
      knife.group.rotation.z = knife.baseRot.z + swing*0.85;
      knife.group.position.x = knife.basePos.x - swing*0.15;
      if (tSec > 1.1){ knife.inspect = false; }
    } else {
      knife.group.rotation.z = THREE.MathUtils.damp(knife.group.rotation.z, knife.baseRot.z, 8, 1/60);
      knife.group.position.x  = THREE.MathUtils.damp(knife.group.position.x, knife.basePos.x, 8, 1/60);
    }

    // trail fade/update
    for (let i=knife.trailPool.length-1;i>=0;i--){
      const m = knife.trailPool[i];
      m.userData.life -= 1000/60;
      m.material.opacity *= 0.92;
      m.position.z -= 0.03;
      m.scale.multiplyScalar(0.985);
      if (m.userData.life <= 0){ camera.remove(m); knife.trailPool.splice(i,1); }
    }
  }

  // call once after camera is created:
  attachKnifeToCamera();

  /* ========= Helpers: spawn position & grace ========= */
  function setStartPosition(){
    const radius = (trackInner + ARENA_RADIUS) * 0.5;
    const theta = Math.PI * 1.5; // bottom
    const x = Math.cos(theta) * radius;
    const z = Math.sin(theta) * radius;
    const player = cars[0];
    player.position.set(x, 0, z);
    player.rotationY = -theta;
    player.mesh.position.set(x,0,z);
    player.mesh.rotation.y = player.rotationY;
    while (cars.length > 1){ const seg = cars.pop(); scene.remove(seg.mesh); }
    spawnGraceUntil = performance.now() + 2500;
  }
  function canDie(){ return performance.now() >= spawnGraceUntil; }

  /* ========= Loop ========= */
  let lastTime = performance.now();
  const sessionStart = performance.now();

  function fmtTime(ms){
    const total = Math.floor(ms/1000);
    const m = Math.floor(total/60);
    const s = total % 60;
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  function animate(){
    requestAnimationFrame(animate);

    const now = performance.now();
    const dtRaw = (now - lastTime)/1000;
    const dt = Math.min(dtRaw, 0.05);
    lastTime = now;

    if (alive){ const elapsed = now - gameStartMs; timerEl.textContent = fmtTime(elapsed); }

    const t = (now - sessionStart)/1000;
    const player = cars[0];

    // XP badge visibility
    if (xpMultActive && now < xpMultUntil){
      xpBadge.style.display = 'flex';
      const rem = (xpMultUntil - now)/1000;
      xpTime.textContent = `${rem.toFixed(1)}s`;
    } else {
      xpMultActive = false; xpBadge.style.display = 'none';
    }

    // Maintain up to 2 gems
    maintainGems();

    // Speed scales with score
    const BASE_MIN   = isMobile ? 7 : 13;
    const BASE_MAX   = isMobile ? 26 : 42;
    const PER_POINT  = isMobile ? 0.35 : 0.6;
    let baseSpeed = BASE_MIN + score * PER_POINT;
    if (baseSpeed > BASE_MAX) baseSpeed = BASE_MAX;

    const ROTATION_SPEED = isMobile ? 2.5 : 3.5;

    if (alive){
      if (keys['a'] || keys['arrowleft']  || touchLeft)  player.rotationY += ROTATION_SPEED * dt;
      if (keys['d'] || keys['arrowright'] || touchRight) player.rotationY -= ROTATION_SPEED * dt;

      if ((keys[' '] && canBoost(player)) || player.boost.active){
        if (keys[' '] && canBoost(player)) startBoost(player);
      }
      updateBoost(player);

      const speed = baseSpeed * (player.boost.active ? BOOST_MULTIPLIER : 1);
      const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotationY);
      player.position.add(fwd.multiplyScalar(speed * dt));

      // followers
      for (let i=1;i<cars.length;i++){
        const lead = cars[i-1], foll = cars[i];
        const dir = new THREE.Vector3().subVectors(lead.position, foll.position);
        const dist = dir.length();
        if (dist > SEGMENT_DISTANCE){
          dir.normalize();
          foll.position.add(dir.multiplyScalar(Math.min(dist-SEGMENT_DISTANCE, speed*dt*1.5)));
        }
        const targetRot = Math.atan2(dir.x, dir.z);
        foll.rotationY += (targetRot - foll.rotationY) * 0.15;
      }

      // apply transforms
      for (let i=0;i<cars.length;i++){
        const c = cars[i];
        c.mesh.position.copy(c.position).setY(0);
        c.mesh.rotation.y = c.rotationY;
      }

      // animate pickups
      for (const p of pickups){
        const y = p.baseY + Math.sin(t*2 + p.phase)*0.3 + 0.8;
        p.mesh.position.y = y;
        p.mesh.rotation.y += 0.02;
      }
      // animate gems
      for (const g of xpGems){
        g.mesh.position.y = 0.9 + Math.sin(t*2.4 + g.phase)*0.35;
        g.mesh.rotation.y += 0.03;
      }

      // collect pickups
      for (let i=pickups.length-1; i>=0; i--){
        if (pickups[i].mesh.position.distanceTo(player.position) < 3){
          scene.remove(pickups[i].mesh); pickups.splice(i,1);
          score += xpMultActive ? 2 : 1;
          scoreEl.textContent = score;
          addFollower(); spawnPickup();
        }
      }
      // collect gems
      for (let i=xpGems.length-1; i>=0; i--){
        if (xpGems[i].mesh.position.distanceTo(player.position) < 3.2){
          scene.remove(xpGems[i].mesh); xpGems.splice(i,1);
          xpMultActive = true; xpMultUntil = now + XP_DURATION_MS;
        }
      }

      // moving barriers start after score >= 8
      const moveFactor = Math.min(1, Math.max(0, (score - 8) / 12));
      if (moveFactor > 0){
        for (const o of obstacles){
          const amp = o.amp * moveFactor;
          const w = o.freq;
          if (o.mode === 'circle'){
            o.mesh.position.x = o.base.x + Math.cos(w*t + o.phase) * amp;
            o.mesh.position.z = o.base.z + Math.sin(w*t + o.phase) * amp;
          } else {
            const s = Math.sin(w*t + o.phase) * amp;
            o.mesh.position.copy(o.base.clone().add(o.dir.clone().multiplyScalar(s)));
          }
          o.mesh.rotation.y += 0.4 * dt * moveFactor;
        }
      } else {
        for (const o of obstacles){ o.mesh.position.copy(o.base); }
      }

      // collisions & wall
      if (canDie()){
        for (const o of obstacles){
          if (o.mesh.position.distanceTo(player.position) < 4.0){ doGameOver(); break; }
        }
        if (player.position.length() > ARENA_RADIUS-1.5){ doGameOver(); }
      }
    }

    updateKnife();

    // camera follow
    const camOffset = new THREE.Vector3(0, 15, -30).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotationY);
    camera.position.copy(player.position.clone().add(camOffset));
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  function totalRR(idx, rr){ return idx*100 + rr; }

  function spawnBursts(centerX, centerY, count=30){
    for(let i=0;i<count;i++){
      const b = document.createElement('div');
      b.className = 'burst';
      const angle = Math.random()*Math.PI*2;
      const dist = 120 + Math.random()*120;
      const dx = Math.cos(angle)*dist, dy = Math.sin(angle)*dist;
      b.style.left = `${centerX}px`; b.style.top = `${centerY}px`;
      b.style.setProperty('--dx', dx+'px');
      b.style.setProperty('--dy', dy+'px');
      b.style.background = `hsl(${Math.floor(Math.random()*360)}, 85%, 65%)`;
      document.body.appendChild(b);
      setTimeout(()=>b.remove(), 900);
    }
  }

  function showRankUpAnimation(idx, promos){
    rankUpBadge.src = rankBadgeDataURI(idx, true);
    rankUpText.textContent = promos >= 2 ? 'DOUBLE PROMOTION!' : 'RANK UP!';
    rankUpOverlay.style.display = 'grid';
    const rect = rankUpOverlay.getBoundingClientRect();
    spawnBursts(rect.width/2, rect.height/2, promos >= 2 ? 60 : 36);
    setTimeout(() => { rankUpOverlay.style.display = 'none'; }, 1100);
  }

  async function doGameOver(){
    if (!alive) return;
    alive = false;
    scoreEl.textContent = score;

    const elapsed = performance.now() - gameStartMs;

    const prevIdx = prevRankIndex;
    const prevRRLocal = prevRR;

    let result = null;
    try{
      result = await applyMatchResultAndSave(playerName || 'Player', score, elapsed);
      await upsertHighScore(playerName || 'Player', score, result.rankIndex);
    }catch(e){ console.error('Rank/leaderboard update failed', e); }

    const newIdx = result ? result.rankIndex : prevIdx;
    const newRR = result ? result.rr : prevRRLocal;
    setHudRank(newIdx, newRR);

    const deltaTotal = totalRR(newIdx, newRR) - totalRR(prevIdx, prevRRLocal);
    const sign = deltaTotal >= 0 ? '+' : '';
    rrDeltaEl.textContent = `(${sign}${deltaTotal} RR)`;
    rrDeltaEl.className = '';
    rrDeltaEl.classList.add(deltaTotal >= 0 ? 'good' : 'bad');

    prevRankEl.textContent = RANKS[prevIdx] || 'Unrated';
    prevRREl.textContent = `RR ${prevRRLocal}`;
    nowRankEl.textContent = RANKS[newIdx] || 'Unrated';
    nowRREl.textContent = `RR ${newRR}`;
    promoNoteEl.textContent = '';
    if (result){
      if (result.promos > 0){
        promoNoteEl.textContent = result.promos >= 2 ? 'üî• Double promotion!' : '‚≠ê Promotion!';
        showRankUpAnimation(newIdx, result.promos);
      } else if (result.deranks > 0){
        promoNoteEl.textContent = '‚¨á Downranked.';
      }
    }

    document.getElementById('finalScore').textContent = score;
    restartNameInput.value = playerName || '';
    restartOverlay.style.display = 'grid';
  }

  /* ========= Start / Restart ========= */
  async function primeRankSnapshotAndHUD(){
    try{
      const p = await getOrCreatePlayerRank(playerName);
      prevRankIndex = p.rankIndex || 0;
      prevRR = p.rr || 0;
      setHudRank(prevRankIndex, prevRR);
    }catch(e){
      console.error(e);
      prevRankIndex = 0; prevRR = 0;
      setHudRank(0,0);
    }
  }

  startBtn.addEventListener('click', async () => {
    const nm = (nameInput.value || '').trim().substring(0,20);
    if (!nm){ nameInput.focus(); return; }
    playerName = nm; localStorage.setItem('f1snake_name', playerName);

    await primeRankSnapshotAndHUD();

    score = 0; scoreEl.textContent = '0';
    xpMultActive = false; xpBadge.style.display='none';
    setStartPosition();
    gameStartMs = performance.now();
    timerEl.textContent = '00:00';
    chatBox.style.display = 'flex';
    startOverlay.style.display = 'none';
    alive = true;
    attachKnifeToCamera();
  });
  nameInput.addEventListener('keydown', e=>{ if (e.key==='Enter') startBtn.click(); });

  restartBtn.addEventListener('click', async () => {
    const nm = (restartNameInput.value || '').trim().substring(0,20);
    playerName = nm || playerName || 'Player';
    localStorage.setItem('f1snake_name', playerName);

    await primeRankSnapshotAndHUD();

    score = 0; scoreEl.textContent = '0';
    xpMultActive = false; xpBadge.style.display='none';
    setStartPosition();
    gameStartMs = performance.now();
    timerEl.textContent = '00:00';
    for (const o of obstacles){ o.mesh.position.copy(o.base); }
    restartOverlay.style.display = 'none';
    alive = true;
    attachKnifeToCamera();
  });

  // Start listeners/render
  startChatListener();
  animate();

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
})();
</script>
</body>
</html>
