<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>F1 Snake ‚Äî Leaderboard + Chat</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  :root{
    --glass: rgba(0,0,0,0.35);
    --panel: rgba(0,0,0,0.75);
    --accent: #00e5ff;
    --danger: #ff3b30;
  }
  html, body {
    margin: 0; height: 100%; overflow: hidden; background: #0b0f14;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: #fff;
    touch-action: none;
  }

  /* HUD (left) */
  #hud {
    position: absolute; top: 14px; left: 14px; z-index: 30;
    background: var(--glass); padding: 10px 12px; border-radius: 12px;
    backdrop-filter: blur(6px);
    width: 260px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }
  #scoreRow { font-weight: 700; font-size: 18px; }
  #hint   { margin-top: 6px; font-size: 12px; opacity: .85; line-height: 1.35; }

  /* Chat (square, under instructions, left) */
  #chat {
    margin-top: 10px;
    width: 260px; height: 260px;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    display: none;            /* shown after name entered */
    flex-direction: column;
    overflow: hidden;
  }
  #chatHeader{
    padding: 8px 10px; font-size: 12px; letter-spacing:.2px; opacity:.9;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  #chatMessages {
    flex: 1; overflow-y: auto; padding: 8px 10px; line-height: 1.35; font-size: 13px;
  }
  #chatInput {
    border: none; outline: none; padding: 10px;
    background: #141920; color: #fff; font-size: 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
  }
  #chatInput::placeholder{ color:#8aa0b4; }

  /* Leaderboard (top-right) */
  #leaderboard {
    position: absolute; top: 14px; right: 14px; z-index: 30;
    width: 280px; max-height: 340px; overflow-y: auto;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 14px; box-shadow: 0 6px 22px rgba(0,0,0,0.45);
    backdrop-filter: blur(6px);
  }
  #lbHeader{
    padding: 10px 14px; border-bottom: 1px solid rgba(255,255,255,0.08);
    display:flex; align-items:center; gap:8px;
  }
  #lbHeader .dot{ width:8px; height:8px; border-radius:50%; background: var(--accent); box-shadow:0 0 10px var(--accent); }
  #lbHeader h3{ margin:0; font-size: 14px; letter-spacing:.3px; font-weight: 700; }
  #lbList{ list-style:none; margin:0; padding: 8px 10px 12px 10px; }
  #lbList li{
    display:flex; justify-content: space-between; align-items:center;
    padding: 8px 8px; margin: 4px 0;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px; font-size: 14px;
  }
  #lbList li .rank{
    width: 22px; height: 22px; border-radius: 6px; display:flex; align-items:center; justify-content:center;
    background: rgba(255,255,255,0.08); font-size: 12px; margin-right: 8px;
  }
  #lbList li .name{ flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  #lbList li .score{ font-weight: 700; color: #b7f; }

  /* Overlays (start/restart) */
  .overlay {
    position: fixed; inset: 0; display: none; place-items: center; z-index: 50;
    background: radial-gradient(60% 60% at 50% 50%, rgba(0,229,255,0.08), rgba(0,0,0,0.9));
    animation: fadeIn .25s ease-out both;
  }
  @keyframes fadeIn { from{opacity:0} to{opacity:1} }
  .panel {
    width: min(560px, 92vw);
    background: rgba(10,14,20,.85);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    padding: 22px 22px 18px;
    text-align: center;
    backdrop-filter: blur(10px);
  }
  .title { font-weight: 800; font-size: 28px; letter-spacing:.3px; margin: 4px 0 6px; }
  .subtitle { opacity:.85; font-size: 14px; margin-bottom: 14px; }
  .inputRow { display:flex; gap:10px; justify-content:center; margin-top: 8px; }
  .textInput {
    width: 260px; padding: 10px 12px; border-radius: 10px; border:1px solid rgba(255,255,255,.12);
    outline:none; background:#0f1620; color:#fff; font-size:15px;
  }
  .btn {
    padding: 10px 16px; border-radius: 10px; border: none; cursor: pointer;
    background: linear-gradient(90deg, #00c6ff, #0072ff); color:#001318; font-weight: 800;
    text-transform: uppercase; letter-spacing:.4px;
    box-shadow: 0 10px 24px rgba(0,114,255,.35);
  }
  .btn:hover{ filter: brightness(1.07); }
  .small { font-size:12px; opacity:.8; margin-top:10px; }
  .scoreBadge{
    display:inline-block; padding: 6px 10px; border-radius: 999px;
    background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12);
    margin-bottom: 8px; font-weight:700;
  }
</style>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <div id="scoreRow">Score: <span id="score">0</span></div>
  <div id="hint">Controls: A/D or ‚óÄÔ∏è/‚ñ∂Ô∏è ‚Ä¢ Touch left/right ‚Ä¢ Double-tap/2-finger = Boost</div>

  <div id="chat">
    <div id="chatHeader">üí¨ Global Chat</div>
    <div id="chatMessages"></div>
    <input id="chatInput" placeholder="Type & press Enter" autocomplete="off" />
  </div>
</div>

<!-- Leaderboard (top-right) -->
<div id="leaderboard">
  <div id="lbHeader"><span class="dot"></span><h3>Top 10 ‚Äî Global Leaderboard</h3></div>
  <ul id="lbList"><li><span class="rank">‚Äì</span><span class="name">Loading‚Ä¶</span><span class="score">‚Äì</span></li></ul>
</div>

<!-- Start overlay -->
<div id="startOverlay" class="overlay" style="display:grid;">
  <div class="panel">
    <div class="title">F1 Snake</div>
    <div class="subtitle">Collect green cones to grow. Dodge red cubes. Boost wisely!</div>
    <div class="inputRow">
      <input id="nameInput" class="textInput" maxlength="20" placeholder="Player name" />
      <button id="startBtn" class="btn">Start</button>
    </div>
    <div class="small">Your last name is remembered on this device.</div>
  </div>
</div>

<!-- Restart overlay -->
<div id="restartOverlay" class="overlay">
  <div class="panel">
    <div class="title">Game Over</div>
    <div class="scoreBadge">Final Score: <span id="finalScore">0</span></div>
    <div class="inputRow">
      <input id="restartNameInput" class="textInput" maxlength="20" placeholder="Player name" />
      <button id="restartBtn" class="btn">Restart</button>
    </div>
    <div class="small">Change your name or keep it the same.</div>
  </div>
</div>

<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script>
(() => {
  /* ========= Firebase ========= */
  const firebaseConfig = {
    apiKey: "AIzaSyC5seSlgxk4mCRn4HKet4rHlzhQVVBxc-8",
    authDomain: "f1-snake.firebaseapp.com",
    projectId: "f1-snake",
    storageBucket: "f1-snake.firebasestorage.app",
    messagingSenderId: "575341092161",
    appId: "1:575341092161:web:b9050e1df88c9e36de95c0"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  /* ========= DOM ========= */
  const startOverlay = document.getElementById('startOverlay');
  const restartOverlay = document.getElementById('restartOverlay');
  const nameInput = document.getElementById('nameInput');
  const startBtn = document.getElementById('startBtn');
  const restartNameInput = document.getElementById('restartNameInput');
  const restartBtn = document.getElementById('restartBtn');
  const scoreEl = document.getElementById('score');
  const chatBox = document.getElementById('chat');
  const chatMessagesEl = document.getElementById('chatMessages');
  const chatInputEl = document.getElementById('chatInput');
  const lbList = document.getElementById('lbList');

  /* ========= State ========= */
  let playerName = localStorage.getItem('f1snake_name') || '';
  if (playerName) { nameInput.value = playerName; }
  let alive = false;
  let score = 0;
  let leaderboardSubmitted = false;

  /* ========= Leaderboard ========= */
  function startLeaderboardListener(){
    db.collection('leaderboard').orderBy('score','desc').limit(10).onSnapshot(snap=>{
      lbList.innerHTML = '';
      let rank = 1;
      snap.forEach(doc=>{
        const d = doc.data();
        const li = document.createElement('li');
        li.innerHTML = `<span class="rank">${rank}</span>
                        <span class="name">${(d.name||'Player')}</span>
                        <span class="score">${d.score||0}</span>`;
        lbList.appendChild(li);
        rank++;
      });
      if (rank === 1){
        const li = document.createElement('li');
        li.innerHTML = `<span class="rank">‚Äì</span><span class="name">No scores yet</span><span class="score">‚Äì</span>`;
        lbList.appendChild(li);
      }
    });
  }
  startLeaderboardListener();

  async function submitScore(name, scoreVal){
    try{
      const q = await db.collection('leaderboard').where('name','==',name).limit(1).get();
      if (!q.empty){
        const docRef = q.docs[0].ref;
        const prev = q.docs[0].data().score || 0;
        if (scoreVal > prev){
          await docRef.update({score: scoreVal, timestamp: firebase.firestore.FieldValue.serverTimestamp()});
        }
      } else {
        await db.collection('leaderboard').add({
          name, score: scoreVal, timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    }catch(e){ console.error(e); }
  }

  /* ========= Chat (last 50) ========= */
  const CHAT_MAX = 50;
  function startChatListener(){
    db.collection('chat').orderBy('timestamp','desc').limit(CHAT_MAX).onSnapshot(snap=>{
      const arr = [];
      snap.forEach(d=>arr.push(d.data()));
      arr.reverse();
      chatMessagesEl.innerHTML = '';
      arr.forEach(m=>{
        const time = m.timestamp ? new Date(m.timestamp.seconds*1000).toLocaleTimeString() : '';
        const div = document.createElement('div');
        div.textContent = `[${time}] ${m.name||'Player'}: ${m.message||''}`;
        chatMessagesEl.appendChild(div);
      });
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    });
  }
  async function sendMessage(text){
    const t = (text||'').trim();
    if (!t) return;
    await db.collection('chat').add({
      name: playerName || 'Player',
      message: t,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });
    // Trim > 50
    const all = await db.collection('chat').orderBy('timestamp','asc').get();
    if (all.size > CHAT_MAX){
      const toDelete = all.docs.slice(0, all.size-CHAT_MAX);
      const batch = db.batch();
      toDelete.forEach(doc=>batch.delete(doc.ref));
      await batch.commit();
    }
  }
  chatInputEl.addEventListener('keydown', e=>{
    if (e.key === 'Enter'){
      e.preventDefault();
      sendMessage(chatInputEl.value);
      chatInputEl.value='';
    }
  });

  /* ========= THREE / Game ========= */
  const ARENA_RADIUS = 120;
  const SEGMENT_DISTANCE = 6;
  const BOOST_MULTIPLIER = 2.4;
  const BOOST_DURATION = 2000;
  const BOOST_COOLDOWN = 4000;
  const OBSTACLE_COUNT = 10;
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0b0f14, 0.0025);
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.5, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x1b2230, 1);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(50, 100, 50); scene.add(dirLight);

  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(ARENA_RADIUS, 64),
    new THREE.MeshStandardMaterial({color:0x0d3b66})
  );
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  // ---- Car Models ----
  function makeHeadCar(primary=0xff2d55, accent=0xffffff){
    const g = new THREE.Group();

    // Wheels
    const wheelMat = new THREE.MeshStandardMaterial({color:0x111111, metalness:.3, roughness:.6});
    const wheelGeo = new THREE.CylinderGeometry(0.6,0.6,0.4,16);
    const wheels = [0,1,2,3].map(()=>new THREE.Mesh(wheelGeo, wheelMat));
    wheels.forEach(w=>{ w.rotation.z = Math.PI/2; w.castShadow = true; w.receiveShadow=true; g.add(w); });
    wheels[0].position.set(-1.2, 0.6,  2.2);
    wheels[1].position.set( 1.2, 0.6,  2.2);
    wheels[2].position.set(-1.2, 0.6, -2.0);
    wheels[3].position.set( 1.2, 0.6, -2.0);

    // Body
    const bodyMat = new THREE.MeshStandardMaterial({color:primary, metalness:.5, roughness:.3});
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.6,5.6), bodyMat);
    body.position.set(0, 0.9, 0); body.castShadow = true; g.add(body);

    // Sidepods
    const podMat = bodyMat;
    const pod = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,3.6), podMat);
    const pod2 = pod.clone();
    pod.position.set(-1.4, 0.85, 0); pod2.position.set(1.4, 0.85, 0);
    g.add(pod); g.add(pod2);

    // Cockpit
    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.0,0.5,1.2),
      new THREE.MeshStandardMaterial({color:accent, metalness:.2, roughness:.6}));
    cockpit.position.set(0, 1.25, 1.0); cockpit.castShadow = true; g.add(cockpit);

    // Front wing
    const fwing = new THREE.Mesh(new THREE.BoxGeometry(3.2,0.15,0.9), bodyMat);
    fwing.position.set(0, 0.75, 3.1); g.add(fwing);

    // Rear wing
    const rwing = new THREE.Mesh(new THREE.BoxGeometry(2.4,0.15,0.6), bodyMat);
    rwing.position.set(0, 1.15, -2.8); g.add(rwing);
    const rwingVert = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.7,0.05), bodyMat);
    rwingVert.position.set(0, 1.0, -2.6); g.add(rwingVert);

    // Nose
    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.5,1.2,14), bodyMat);
    nose.rotation.x = Math.PI; nose.position.set(0,0.95,3.5); g.add(nose);

    return g;
  }

  function makeTailCar(primary=0xff8a00, trim=0x333333){
    const g = new THREE.Group();

    // Slim body
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.5,4.2),
      new THREE.MeshStandardMaterial({color:primary, metalness:.4, roughness:.4}));
    body.position.set(0,0.85,0); g.add(body);

    // Low cockpit bump
    const bump = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.35,0.9),
      new THREE.MeshStandardMaterial({color:0xffffff, metalness:.2, roughness:.6}));
    bump.position.set(0,1.1,0.6); g.add(bump);

    // Small rear wing
    const wing = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.12,0.45),
      new THREE.MeshStandardMaterial({color:primary, metalness:.4, roughness:.4}));
    wing.position.set(0,1.05,-2.1); g.add(wing);

    // Two wheels as discs
    const wheelMat = new THREE.MeshStandardMaterial({color:trim, metalness:.3, roughness:.6});
    const wheelGeo = new THREE.CylinderGeometry(0.5,0.5,0.3,14);
    const w1 = new THREE.Mesh(wheelGeo, wheelMat), w2 = new THREE.Mesh(wheelGeo, wheelMat);
    w1.rotation.z = Math.PI/2; w2.rotation.z = Math.PI/2;
    w1.position.set(-1.1,0.6,0.8); w2.position.set(1.1,0.6,0.8);
    g.add(w1); g.add(w2);

    return g;
  }

  // ---- Cars list + spawn ----
  const cars = [];
  cars.push({
    position: new THREE.Vector3(0,0,0),
    rotationY: 0,
    mesh: makeHeadCar(0xff2d55, 0xbfd8ff),
    boost: {active:false, cooldown:0, timer:0}
  });
  scene.add(cars[0].mesh);
  cars[0].mesh.position.set(0,0,0);

  function addFollower(){
    const leader = cars[cars.length-1];
    const follower = {
      position: new THREE.Vector3().copy(leader.position),
      rotationY: leader.rotationY,
      mesh: makeTailCar(0xff8a00, 0x222222),
    };
    const back = new THREE.Vector3(0,0,-SEGMENT_DISTANCE).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotationY);
    follower.position.add(back);
    scene.add(follower.mesh);
    cars.push(follower);
  }

  // ---- Pickups & obstacles ----
  const pickups = [];
  function spawnPickup(){
    const r = THREE.MathUtils.randFloat(10, ARENA_RADIUS-10);
    const a = THREE.MathUtils.randFloat(0, Math.PI*2);
    const x = Math.cos(a)*r, z = Math.sin(a)*r;
    const cone = new THREE.Mesh(new THREE.ConeGeometry(1.2,2.2,10), new THREE.MeshStandardMaterial({color:0x00ffae}));
    cone.position.set(x,1.1,z); cone.rotation.x = Math.PI;
    scene.add(cone); pickups.push(cone);
  }
  for(let i=0;i<6;i++) spawnPickup();

  // Moving obstacle data structure
  const obstacles = []; // each: {mesh, base:Vector3, mode, amp, freq, phase, dir:Vector3}
  function spawnObstacles(){
    for(let i=0;i<OBSTACLE_COUNT;i++){
      const r = THREE.MathUtils.randFloat(15, ARENA_RADIUS-15);
      const a = THREE.MathUtils.randFloat(0, Math.PI*2);
      const x = Math.cos(a)*r, z = Math.sin(a)*r;
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(6,6,6), new THREE.MeshStandardMaterial({color:0xaa0000}));
      mesh.position.set(x,3,z);
      scene.add(mesh);

      // assign a movement pattern
      const mode = (i % 2 === 0) ? 'circle' : 'bounce';
      const amp = THREE.MathUtils.randFloat(4, 10);
      const freq = THREE.MathUtils.randFloat(0.2, 0.5);
      const phase = Math.random() * Math.PI * 2;
      let dir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5);
      if (dir.lengthSq() < 0.01) dir.set(1,0,0);
      dir.normalize();

      obstacles.push({ mesh, base: mesh.position.clone(), mode, amp, freq, phase, dir });
    }
  }
  spawnObstacles();

  // ---- Input ----
  const keys = {};
  window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup',   e=> keys[e.key.toLowerCase()] = false);

  let touchLeft=false, touchRight=false, lastTap=0;
  function handleTouchStart(e){
    e.preventDefault();
    if (e.touches.length===1){
      const x = e.touches[0].clientX;
      (x < innerWidth/2) ? touchLeft=true : touchRight=true;
    } else if (e.touches.length===2){
      if (canBoost(cars[0])) startBoost(cars[0]);
    }
  }
  function handleTouchEnd(e){ e.preventDefault(); touchLeft=false; touchRight=false; }
  function handleTap(){
    const now = Date.now();
    if (now - lastTap < 300){ if (canBoost(cars[0])) startBoost(cars[0]); }
    lastTap = now;
  }
  window.addEventListener('touchstart', handleTouchStart, {passive:false});
  window.addEventListener('touchend',   handleTouchEnd,   {passive:false});
  window.addEventListener('touchcancel',handleTouchEnd,   {passive:false});
  window.addEventListener('click', handleTap);

  function canBoost(car){
    const t = performance.now();
    if (car.boost.cooldown && t < car.boost.cooldown) return false;
    return true;
  }
  function startBoost(car){
    const t = performance.now();
    car.boost.active = true;
    car.boost.timer = t + BOOST_DURATION;
    car.boost.cooldown = t + BOOST_DURATION + BOOST_COOLDOWN;
  }
  function updateBoost(car){
    const t = performance.now();
    if (car.boost.active && t > car.boost.timer) car.boost.active = false;
  }

  /* ========= Loop ========= */
  let lastTime = performance.now();
  const startTime = performance.now();

  function animate(){
    requestAnimationFrame(animate);

    const now = performance.now();
    const dtRaw = (now - lastTime)/1000;
    const dt = Math.min(dtRaw, 0.05);
    lastTime = now;

    const t = (now - startTime)/1000;
    const player = cars[0];

    // ---- Dynamic speed scaling with score ----
    // Base speed increases as you gain points; capped for control.
    const BASE_MIN   = isMobile ? 7 : 13;
    const BASE_MAX   = isMobile ? 26 : 42;
    const PER_POINT  = isMobile ? 0.35 : 0.6;
    let baseSpeed = BASE_MIN + score * PER_POINT;
    if (baseSpeed > BASE_MAX) baseSpeed = BASE_MAX;

    const ROTATION_SPEED = isMobile ? 2.5 : 3.5;

    if (alive){
      if (keys['a'] || keys['arrowleft']  || touchLeft)  player.rotationY += ROTATION_SPEED * dt;
      if (keys['d'] || keys['arrowright'] || touchRight) player.rotationY -= ROTATION_SPEED * dt;

      if ((keys[' '] && canBoost(player)) || player.boost.active){
        if (keys[' '] && canBoost(player)) startBoost(player);
      }
      updateBoost(player);

      const speed = baseSpeed * (player.boost.active ? BOOST_MULTIPLIER : 1);
      const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotationY);
      player.position.add(fwd.multiplyScalar(speed * dt));

      // followers
      for (let i=1;i<cars.length;i++){
        const lead = cars[i-1], foll = cars[i];
        const dir = new THREE.Vector3().subVectors(lead.position, foll.position);
        const dist = dir.length();
        if (dist > SEGMENT_DISTANCE){
          dir.normalize();
          foll.position.add(dir.multiplyScalar(Math.min(dist-SEGMENT_DISTANCE, speed*dt*1.5)));
        }
        const targetRot = Math.atan2(dir.x, dir.z);
        foll.rotationY += (targetRot - foll.rotationY) * 0.15;
      }

      // apply transforms
      for (let i=0;i<cars.length;i++){
        const c = cars[i];
        c.mesh.position.copy(c.position).setY(0);
        c.mesh.rotation.y = c.rotationY;
      }

      // pickups
      for (let i=pickups.length-1; i>=0; i--){
        if (pickups[i].position.distanceTo(player.position) < 3){
          scene.remove(pickups[i]); pickups.splice(i,1);
          score++; scoreEl.textContent = score;
          addFollower(); spawnPickup();
        }
      }

      // ---- Moving obstacles after some score ----
      // Start moving them gradually after score >= 8; full motion by score 20.
      const moveFactor = Math.min(1, Math.max(0, (score - 8) / 12)); // 0..1
      if (moveFactor > 0){
        for (const o of obstacles){
          const amp = o.amp * moveFactor;
          const w = o.freq;
          if (o.mode === 'circle'){
            o.mesh.position.x = o.base.x + Math.cos(w*t + o.phase) * amp;
            o.mesh.position.z = o.base.z + Math.sin(w*t + o.phase) * amp;
          } else { // bounce along a direction
            const s = Math.sin(w*t + o.phase) * amp;
            o.mesh.position.copy(o.base.clone().add(o.dir.clone().multiplyScalar(s)));
          }
          o.mesh.rotation.y += 0.4 * dt * moveFactor; // subtle spin
        }
      } else {
        // keep them at base if not moving yet
        for (const o of obstacles){
          o.mesh.position.copy(o.base);
        }
      }

      // obstacles collision
      for (const o of obstacles){
        if (o.mesh.position.distanceTo(player.position) < 4.5){
          doGameOver(); break;
        }
      }

      // boundary
      if (player.position.length() > ARENA_RADIUS){
        doGameOver();
      }
    }

    // camera follow
    const camOffset = new THREE.Vector3(0, 15, -30).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotationY);
    camera.position.copy(player.position.clone().add(camOffset));
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  function doGameOver(){
    if (!alive) return;
    alive = false;
    scoreEl.textContent = score;
    if (!leaderboardSubmitted){
      leaderboardSubmitted = true;
      submitScore(playerName || 'Player', score);
    }
    document.getElementById('finalScore').textContent = score;
    restartNameInput.value = playerName || '';
    restartOverlay.style.display = 'grid';
  }

  /* ========= Start / Restart ========= */
  startBtn.addEventListener('click', () => {
    const nm = (nameInput.value || '').trim().substring(0,20);
    if (!nm){ nameInput.focus(); return; }
    playerName = nm; localStorage.setItem('f1snake_name', playerName);
    score = 0; scoreEl.textContent = '0'; leaderboardSubmitted = false; alive = true;
    chatBox.style.display = 'flex';
    startOverlay.style.display = 'none';
  });
  nameInput.addEventListener('keydown', e=>{ if (e.key==='Enter') startBtn.click(); });

  restartBtn.addEventListener('click', () => {
    const nm = (restartNameInput.value || '').trim().substring(0,20);
    playerName = nm || playerName || 'Player';
    localStorage.setItem('f1snake_name', playerName);
    // reset game state
    score = 0; scoreEl.textContent = '0'; leaderboardSubmitted = false; alive = true;
    // back to only head
    while (cars.length > 1){ const seg = cars.pop(); scene.remove(seg.mesh); }
    cars[0].position.set(0,0,0); cars[0].rotationY = 0;
    cars[0].mesh.position.set(0,0,0); cars[0].mesh.rotation.y = 0;
    // reset obstacles to base positions so pattern restarts cleanly
    for (const o of obstacles){ o.mesh.position.copy(o.base); }
    restartOverlay.style.display = 'none';
  });

  // Start listeners/render
  startChatListener();
  animate();

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
})();
</script>
</body>
</html>
