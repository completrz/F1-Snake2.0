<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>F1 Snake with Live Leaderboard</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; background: #111;
    font-family: sans-serif;
    touch-action: none;
  }
  #ui {
    position: absolute; top: 12px; left: 12px; color: #fff; z-index: 10;
    background: rgba(0,0,0,0.25); padding: 8px 12px; border-radius: 8px;
    user-select: none;
    display: none;
  }
  #leaderboard {
    position: absolute;
    top: 12px; right: 12px;
    background: rgba(0,0,0,0.85);
    color: #0ff;
    padding: 15px 20px;
    border-radius: 12px;
    font-size: 1rem;
    max-width: 200px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 20;
    box-shadow: 0 0 12px #0ff;
  }
  #leaderboard h2 {
    margin-top: 0;
    text-align: center;
    color: #0ff;
    font-weight: bold;
    font-size: 1.3rem;
  }
  #leaderboard ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
  }
  #leaderboard li {
    margin: 6px 0;
    padding: 4px 0;
    border-bottom: 1px solid #0ff33aa;
  }
  #namePromptOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: #000d;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    flex-direction: column;
    color: #0ff;
    font-family: monospace;
  }
  #nameInput {
    font-size: 1.5rem;
    padding: 8px 12px;
    border-radius: 6px;
    border: none;
    width: 300px;
    max-width: 90vw;
    margin-top: 12px;
    text-align: center;
  }
  #startBtn {
    margin-top: 15px;
    background: #0ff;
    border: none;
    color: black;
    font-weight: bold;
    padding: 8px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.2rem;
  }
</style>

<!-- Firebase App (the core Firebase SDK) -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<!-- Firestore SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

</head>
<body>

<div id="namePromptOverlay">
  <div>Enter your player name:</div>
  <input id="nameInput" maxlength="20" placeholder="Your name"/>
  <button id="startBtn">Start Game</button>
</div>

<div id="ui">
  Score: <span id="score">0</span><br/>
  Controls: A/D or ‚óÄÔ∏è/‚ñ∂Ô∏è or touch left/right half, double tap or two-finger tap to boost
</div>

<div id="leaderboard">
  <h2>üèÜ Leaderboard</h2>
  <ul id="leaderboard-list"></ul>
</div>

<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script>
(() => {
  // --- Firebase setup ---

  // REPLACE these with your Firebase project config values
  const firebaseConfig = {
    apiKey: "AIzaSyC5seSlgxk4mCRn4HKet4rHlzhQVVBxc-8",
    authDomain: "f1-snake.firebaseapp.com",
    projectId: "f1-snake",
    storageBucket: "f1-snake.firebasestorage.app",
    messagingSenderId: "575341092161",
    appId: "1:575341092161:web:b9050e1df88c9e36de95c0",
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  let playerName = '';
  let score = 0;
  let alive = false;

  const namePromptOverlay = document.getElementById('namePromptOverlay');
  const nameInput = document.getElementById('nameInput');
  const startBtn = document.getElementById('startBtn');
  const ui = document.getElementById('ui');
  const scoreEl = document.getElementById('score');
  const leaderboardList = document.getElementById('leaderboard-list');

  // Submit or update player's score if higher
  async function submitScoreIfHigher(name, score) {
    if (!name) return;
    try {
      const docRef = db.collection('leaderboard').doc(name);
      const doc = await docRef.get();
      if (!doc.exists || doc.data().score < score) {
        await docRef.set({
          name: name,
          score: score,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    } catch(e) {
      console.error('Error saving score:', e);
    }
  }

  // Real-time leaderboard listener
  function listenLeaderboard() {
    db.collection('leaderboard')
      .orderBy('score', 'desc')
      .limit(10)
      .onSnapshot(snapshot => {
        leaderboardList.innerHTML = '';
        snapshot.forEach(doc => {
          const entry = doc.data();
          const li = document.createElement('li');
          li.textContent = `${entry.name}: ${entry.score}`;
          leaderboardList.appendChild(li);
        });
      }, err => {
        console.error('Leaderboard listen error:', err);
      });
  }

  startBtn.onclick = () => {
    const name = nameInput.value.trim().substring(0, 20);
    if (!name) {
      alert('Please enter a valid name.');
      return;
    }
    playerName = name;
    alive = true;
    namePromptOverlay.style.display = 'none';
    ui.style.display = 'block';
    listenLeaderboard();
  };

  // --- Game code ---

  const ARENA_RADIUS = 120;
  const SEGMENT_DISTANCE = 6;
  const BOOST_MULTIPLIER = 2.4;
  const BOOST_DURATION = 2000;
  const BOOST_COOLDOWN = 4000;
  const OBSTACLE_COUNT = 10;

  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x111111, 0.0025);
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.5, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(50, 100, 50);
  scene.add(dirLight);

  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(ARENA_RADIUS, 64),
    new THREE.MeshStandardMaterial({color:0x0d3b66})
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  function makeCar(color=0xff2d55) {
    const group = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(3.4, 1.2, 7.6),
      new THREE.MeshStandardMaterial({color})
    );
    body.position.y = 0.6;
    group.add(body);
    return group;
  }

  const cars = [];
  cars.push({
    position: new THREE.Vector3(0, 0, 0),
    rotationY: 0,
    mesh: makeCar(0xff2d55),
    boost: { active: false, cooldown: 0, timer: 0 }
  });
  scene.add(cars[0].mesh);
  cars[0].mesh.position.set(0, 0, 0);

  function addFollower() {
    const leader = cars[cars.length - 1];
    const follower = {
      position: new THREE.Vector3().copy(leader.position),
      rotationY: leader.rotationY,
      mesh: makeCar(0xff8a00),
    };
    const backOffset = new THREE.Vector3(0, 0, -SEGMENT_DISTANCE).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotationY);
    follower.position.add(backOffset);
    scene.add(follower.mesh);
    cars.push(follower);
  }

  const pickups = [];
  function spawnPickup() {
    const r = THREE.MathUtils.randFloat(10, ARENA_RADIUS - 10);
    const a = THREE.MathUtils.randFloat(0, Math.PI * 2);
    const x = Math.cos(a) * r, z = Math.sin(a) * r;
    const coneGeo = new THREE.ConeGeometry(1.2, 2.2, 10);
    const coneMat = new THREE.MeshStandardMaterial({ color: 0x00ffae });
    const mesh = new THREE.Mesh(coneGeo, coneMat);
    mesh.position.set(x, 1.1, z);
    mesh.rotation.x = Math.PI;
    scene.add(mesh);
    pickups.push(mesh);
  }
  for (let i = 0; i < 6; i++) spawnPickup();

  const obstacles = [];
  function spawnObstacles() {
    for(let i=0; i < OBSTACLE_COUNT; i++) {
      const r = THREE.MathUtils.randFloat(15, ARENA_RADIUS - 15);
      const a = THREE.MathUtils.randFloat(0, Math.PI * 2);
      const x = Math.cos(a) * r, z = Math.sin(a) * r;
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(6, 6, 6),
        new THREE.MeshStandardMaterial({color: 0xaa0000})
      );
      mesh.position.set(x, 3, z);
      scene.add(mesh);
      obstacles.push(mesh);
    }
  }
  spawnObstacles();

  const keys = {};
  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  let touchLeft = false;
  let touchRight = false;
  let lastTap = 0;

  function handleTouchStart(e) {
    e.preventDefault();
    if (e.touches.length === 1) {
      const touchX = e.touches[0].clientX;
      if (touchX < window.innerWidth / 2) {
        touchLeft = true;
      } else {
        touchRight = true;
      }
    } else if (e.touches.length === 2) {
      if (canBoost(cars[0])) {
        startBoost(cars[0]);
      }
    }
  }
  function handleTouchEnd(e) {
    e.preventDefault();
    touchLeft = false;
    touchRight = false;
  }
  function handleTap(e) {
    const now = Date.now();
    if (now - lastTap < 300) {
      if (canBoost(cars[0])) startBoost(cars[0]);
    }
    lastTap = now;
  }
  window.addEventListener('touchstart', handleTouchStart, { passive: false });
  window.addEventListener('touchend', handleTouchEnd, { passive: false });
  window.addEventListener('touchcancel', handleTouchEnd, { passive: false });
  window.addEventListener('click', handleTap);

  function canBoost(car) {
    const now = performance.now();
    if (car.boost.cooldown && now < car.boost.cooldown) return false;
    return true;
  }
  function startBoost(car) {
    const now = performance.now();
    car.boost.active = true;
    car.boost.timer = now + BOOST_DURATION;
    car.boost.cooldown = now + BOOST_DURATION + BOOST_COOLDOWN;
  }
  function updateBoost(car) {
    const now = performance.now();
    if (car.boost.active && now > car.boost.timer) {
      car.boost.active = false;
    }
  }

  async function trySubmitScore() {
    if (playerName && alive) {
      await submitScoreIfHigher(playerName, score);
    }
  }

  let lastTime = performance.now();

  function gameOver() {
    alive = false;
    scoreEl.textContent = `Game Over! Final Score: ${score}`;
    trySubmitScore();
  }

  async function animate() {
    requestAnimationFrame(animate);
    if (!alive) {
      renderer.render(scene, camera);
      return;
    }

    const now = performance.now();
    const deltaRaw = (now - lastTime) / 1000;
    const delta = Math.min(deltaRaw, 0.05);
    lastTime = now;

    const player = cars[0];

    const BASE_SPEED = isMobile ? 7 : 15;
    const ROTATION_SPEED = isMobile ? 2.5 : 3.5;

    if (keys['a'] || keys['arrowleft'] || touchLeft) player.rotationY += ROTATION_SPEED * delta;
    if (keys['d'] || keys['arrowright'] || touchRight) player.rotationY -= ROTATION_SPEED * delta;

    if ((keys[' '] && canBoost(player)) || player.boost.active) {
      if (keys[' '] && canBoost(player)) startBoost(player);
    }
    updateBoost(player);

    const speed = BASE_SPEED * (player.boost.active ? BOOST_MULTIPLIER : 1);

    const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotationY);
    player.position.add(forward.multiplyScalar(speed * delta));

    for (let i = 1; i < cars.length; i++) {
      const leader = cars[i - 1];
      const follower = cars[i];
      const dir = new THREE.Vector3().subVectors(leader.position, follower.position);
      const dist = dir.length();
      if (dist > SEGMENT_DISTANCE) {
        dir.normalize();
        follower.position.add(dir.multiplyScalar(Math.min(dist - SEGMENT_DISTANCE, speed * delta * 1.5)));
      }
      const targetRotation = Math.atan2(dir.x, dir.z);
      follower.rotationY += (targetRotation - follower.rotationY) * 0.15;
    }

    for (let i = 0; i < cars.length; i++) {
      const c = cars[i];
      c.mesh.position.copy(c.position).setY(0.6);
      c.mesh.rotation.y = c.rotationY;
    }

    for (let i = pickups.length - 1; i >= 0; i--) {
      if (pickups[i].position.distanceTo(player.position) < 3) {
        scene.remove(pickups[i]);
        pickups.splice(i, 1);
        score++;
        scoreEl.textContent = score;
        addFollower();
        spawnPickup();
        await trySubmitScore();
      }
    }

    for(const obs of obstacles){
      if(obs.position.distanceTo(player.position) < 4.5){
        gameOver();
      }
    }

    if (player.position.length() > ARENA_RADIUS) {
      gameOver();
    }

    const camOffset = new THREE.Vector3(0, 15, -30).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotationY);
    camera.position.copy(player.position.clone().add(camOffset));
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
})();
</script>
</body>
</html>
