<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>F1 Snake with Live Leaderboard & Restart & Speed Up</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; background: #111;
    font-family: sans-serif;
    touch-action: none;
  }
  #ui {
    position: absolute; top: 12px; left: 12px; color: #fff; z-index: 10;
    background: rgba(0,0,0,0.25); padding: 8px 12px; border-radius: 8px;
    user-select: none;
    display: none;
  }
  #leaderboard {
    position: absolute;
    top: 12px; right: 12px;
    background: rgba(0,0,0,0.85);
    color: #0ff;
    padding: 15px 20px;
    border-radius: 12px;
    font-size: 1rem;
    max-width: 200px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 20;
    box-shadow: 0 0 12px #0ff;
  }
  #leaderboard h2 {
    margin-top: 0;
    text-align: center;
    color: #0ff;
    font-weight: bold;
    font-size: 1.3rem;
  }
  #leaderboard ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
  }
  #leaderboard li {
    margin: 6px 0;
    padding: 4px 0;
    border-bottom: 1px solid #0ff33aa;
  }
  #namePromptOverlay, #restartOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: #000d;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    flex-direction: column;
    color: #0ff;
    font-family: monospace;
  }
  #nameInput, #restartNameInput {
    font-size: 1.5rem;
    padding: 8px 12px;
    border-radius: 6px;
    border: none;
    width: 300px;
    max-width: 90vw;
    margin-top: 12px;
    text-align: center;
  }
  #startBtn, #restartBtn {
    margin-top: 15px;
    background: #0ff;
    border: none;
    color: black;
    font-weight: bold;
    padding: 8px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.2rem;
  }
  #gameOverMsg {
    font-size: 2rem;
    font-weight: bold;
  }
</style>

<!-- Firebase App (the core Firebase SDK) -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<!-- Firestore SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

</head>
<body>

<div id="namePromptOverlay">
  <div>Enter your player name:</div>
  <input id="nameInput" maxlength="20" placeholder="Your name"/>
  <button id="startBtn">Start Game</button>
</div>

<div id="restartOverlay" style="display:none;">
  <div id="gameOverMsg">Game Over!</div>
  <div>Your score: <span id="finalScore">0</span></div>
  <div>Enter name to restart:</div>
  <input id="restartNameInput" maxlength="20" />
  <button id="restartBtn">Restart</button>
</div>

<div id="ui">
  Score: <span id="score">0</span><br/>
  Controls: A/D or ‚óÄÔ∏è/‚ñ∂Ô∏è or touch left/right half, double tap or two-finger tap to boost
</div>

<div id="leaderboard">
  <h2>üèÜ Leaderboard</h2>
  <ul id="leaderboard-list"></ul>
</div>

<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script>
(() => {
  // --- Firebase setup ---

  // REPLACE these with your Firebase project config values
  const firebaseConfig = {
    apiKey: "AIzaSyC5seSlgxk4mCRn4HKet4rHlzhQVVBxc-8",
  authDomain: "f1-snake.firebaseapp.com",
  projectId: "f1-snake",
  storageBucket: "f1-snake.firebasestorage.app",
  messagingSenderId: "575341092161",
  appId: "1:575341092161:web:b9050e1df88c9e36de95c0",
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  let playerName = '';
  let score = 0;
  let alive = false;

  const namePromptOverlay = document.getElementById('namePromptOverlay');
  const nameInput = document.getElementById('nameInput');
  const startBtn = document.getElementById('startBtn');

  const restartOverlay = document.getElementById('restartOverlay');
  const finalScoreSpan = document.getElementById('finalScore');
  const restartNameInput = document.getElementById('restartNameInput');
  const restartBtn = document.getElementById('restartBtn');

  const ui = document.getElementById('ui');
  const scoreEl = document.getElementById('score');
  const leaderboardList = document.getElementById('leaderboard-list');

  // Submit or update player's score if higher
  async function submitScoreIfHigher(name, score) {
    if (!name) return;
    try {
      const docRef = db.collection('leaderboard').doc(name);
      const doc = await docRef.get();
      if (!doc.exists || doc.data().score < score) {
        await docRef.set({
          name: name,
          score: score,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    } catch(e) {
      console.error('Error saving score:', e);
    }
  }

  // Real-time leaderboard listener
  function listenLeaderboard() {
    db.collection('leaderboard')
      .orderBy('score', 'desc')
      .limit(10)
      .onSnapshot(snapshot => {
        leaderboardList.innerHTML = '';
        snapshot.forEach(doc => {
          const entry = doc.data();
          const li = document.createElement('li');
          li.textContent = `${entry.name}: ${entry.score}`;
          leaderboardList.appendChild(li);
        });
      }, err => {
        console.error('Leaderboard listen error:', err);
      });
  }

  function startGame() {
    alive = true;
    score = 0;
    scoreEl.textContent = '0';
    namePromptOverlay.style.display = 'none';
    restartOverlay.style.display = 'none';
    ui.style.display = 'block';
    initGameObjects();
    listenLeaderboard();
  }

  function showRestartScreen() {
    alive = false;
    finalScoreSpan.textContent = score;
    restartNameInput.value = playerName;
    ui.style.display = 'none';
    restartOverlay.style.display = 'flex';
  }

  startBtn.onclick = () => {
    const name = nameInput.value.trim().substring(0, 20);
    if (!name) {
      alert('Please enter a valid name.');
      return;
    }
    playerName = name;
    startGame();
  };

  restartBtn.onclick = () => {
    const name = restartNameInput.value.trim().substring(0, 20);
    if (!name) {
      alert('Please enter a valid name.');
      return;
    }
    playerName = name;
    startGame();
  };

  // --- Game code ---

  const ARENA_RADIUS = 120;
  const SEGMENT_DISTANCE = 6;
  const BOOST_MULTIPLIER = 2.4;
  const BOOST_DURATION = 2000;
  const BOOST_COOLDOWN = 4000;
  const OBSTACLE_COUNT = 10;

  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  let scene, camera, renderer;
  let hemiLight, dirLight, ground;
  let cars = [];
  let pickups = [];
  let obstacles = [];
  let keys = {};
  let touchLeft = false;
  let touchRight = false;
  let lastTap = 0;
  let lastTime = 0;

  function initGameObjects() {
    if(renderer){
      scene.clear();
      cars.forEach(c => scene.remove(c.mesh));
      pickups.forEach(p => scene.remove(p));
      obstacles.forEach(o => scene.remove(o));
    } else {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x111111, 0.0025);

      camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.5, 1000);
      renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setSize(innerWidth, innerHeight);
      if(!document.body.contains(renderer.domElement)) {
        document.body.appendChild(renderer.domElement);
      }
    }

    hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    scene.add(hemiLight);

    dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);

    ground = new THREE.Mesh(
      new THREE.CircleGeometry(ARENA_RADIUS, 64),
      new THREE.MeshStandardMaterial({color:0x0d3b66})
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    cars = [];
    pickups = [];
    obstacles = [];
    keys = {};
    touchLeft = false;
    touchRight = false;
    lastTap = 0;
    lastTime = performance.now();

    function makeCar(color=0xff2d55) {
      const group = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(3.4, 1.2, 7.6),
        new THREE.MeshStandardMaterial({color})
      );
      body.position.y = 0.6;
      group.add(body);
      return group;
    }

    // Start with ONLY 1 car at origin, no followers yet
    const mainCar = {
      position: new THREE.Vector3(0, 0, 0),
      rotationY: 0,
      mesh: makeCar(0xff2d55),
      boost: { active: false, cooldown: 0, timer: 0 }
    };
    scene.add(mainCar.mesh);
    mainCar.mesh.position.set(0, 0, 0);
    cars.push(mainCar);

    // Followers start directly behind main car with proper spacing
    function addFollower() {
      const leader = cars[cars.length - 1];
      const backOffset = new THREE.Vector3(0, 0, -SEGMENT_DISTANCE);
      backOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), leader.rotationY);

      const followerPos = leader.position.clone().add(backOffset);
      const follower = {
        position: followerPos,
        rotationY: leader.rotationY,
        mesh: makeCar(0xff8a00),
      };
      follower.mesh.position.copy(follower.position);
      scene.add(follower.mesh);
      cars.push(follower);
    }
    window.addFollower = addFollower;

    function spawnPickup() {
      const r = THREE.MathUtils.randFloat(10, ARENA_RADIUS - 10);
      const a = THREE.MathUtils.randFloat(0, Math.PI * 2);
      const x = Math.cos(a) * r, z = Math.sin(a) * r;
      const coneGeo = new THREE.ConeGeometry(1.2, 2.2, 10);
      const coneMat = new THREE.MeshStandardMaterial({ color: 0x00ffae });
      const mesh = new THREE.Mesh(coneGeo, coneMat);
      mesh.position.set(x, 1.1, z);
      mesh.rotation.x = Math.PI;
      scene.add(mesh);
      pickups.push(mesh);
    }
    for (let i = 0; i < 6; i++) spawnPickup();

    function spawnObstacles() {
      for(let i=0; i < OBSTACLE_COUNT; i++) {
        const r = THREE.MathUtils.randFloat(15, ARENA_RADIUS - 15);
        const a = THREE.MathUtils.randFloat(0, Math.PI * 2);
        const x = Math.cos(a) * r, z = Math.sin(a) * r;
        const mesh = new THREE.Mesh(
          new THREE.BoxGeometry(6, 6, 6),
          new THREE.MeshStandardMaterial({color: 0xaa0000})
        );
        mesh.position.set(x, 3, z);
        scene.add(mesh);
        obstacles.push(mesh);
      }
    }
    spawnObstacles();

    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    window.addEventListener('touchstart', handleTouchStart, { passive: false });
    window.addEventListener('touchend', handleTouchEnd, { passive: false });
    window.addEventListener('touchcancel', handleTouchEnd, { passive: false });
    window.addEventListener('click', handleTap);
  }

  function canBoost(car) {
    const now = performance.now();
    if (car.boost.cooldown && now < car.boost.cooldown) return false;
    return true;
  }
  function startBoost(car) {
    const now = performance.now();
    car.boost.active = true;
    car.boost.timer = now + BOOST_DURATION;
    car.boost.cooldown = now + BOOST_DURATION + BOOST_COOLDOWN;
  }
  function updateBoost(car) {
    const now = performance.now();
    if (car.boost.active && now > car.boost.timer) {
      car.boost.active = false;
    }
  }

  function handleTouchStart(e) {
    e.preventDefault();
    if (e.touches.length === 1) {
      const touchX = e.touches[0].clientX;
      if (touchX < window.innerWidth / 2) {
        touchLeft = true;
      } else {
        touchRight = true;
      }
    } else if (e.touches.length === 2) {
      if (canBoost(cars[0])) {
        startBoost(cars[0]);
      }
    }
  }
  function handleTouchEnd(e) {
    e.preventDefault();
    touchLeft = false;
    touchRight = false;
  }
  function handleTap(e) {
    const now = Date.now();
    if (now - lastTap < 300) {
      if (canBoost(cars[0])) startBoost(cars[0]);
    }
    lastTap = now;
  }

  async function trySubmitScore() {
    if (playerName && alive) {
      await submitScoreIfHigher(playerName, score);
    }
  }

  async function animate() {
    requestAnimationFrame(animate);
    if (!alive) {
      renderer.render(scene, camera);
      return;
    }

    const now = performance.now();
    const deltaRaw = (now - lastTime) / 1000;
    const delta = Math.min(deltaRaw, 0.05);
    lastTime = now;

    const player = cars[0];

    // Speed increases with score (up to a max)
    const baseSpeed = isMobile ? 7 : 15;
    const maxSpeed = isMobile ? 25 : 40;
    const speedIncreasePerPoint = isMobile ? 0.35 : 0.6;
    let dynamicSpeed = baseSpeed + score * speedIncreasePerPoint;
    if(dynamicSpeed > maxSpeed) dynamicSpeed = maxSpeed;

    const ROTATION_SPEED = isMobile ? 2.5 : 3.5;

    if (keys['a'] || keys['arrowleft'] || touchLeft) player.rotationY += ROTATION_SPEED * delta;
    if (keys['d'] || keys['arrowright'] || touchRight) player.rotationY -= ROTATION_SPEED * delta;

    if ((keys[' '] && canBoost(player)) || player.boost.active) {
      if (keys[' '] && canBoost(player)) startBoost(player);
    }
    updateBoost(player);

    const speed = dynamicSpeed * (player.boost.active ? BOOST_MULTIPLIER : 1);

    // Move main car forward
    const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotationY);
    player.position.add(forward.multiplyScalar(speed * delta));
    player.mesh.position.copy(player.position);
    player.mesh.rotation.y = player.rotationY;

    // Move followers
    for (let i = 1; i < cars.length; i++) {
      const leader = cars[i - 1];
      const follower = cars[i];
      const dir = new THREE.Vector3().subVectors(leader.position, follower.position);
      const dist = dir.length();
      if (dist > SEGMENT_DISTANCE) {
        dir.normalize();
        follower.position.add(dir.multiplyScalar(Math.min(dist - SEGMENT_DISTANCE, speed * delta * 1.5)));
      }
      const targetRotation = Math.atan2(dir.x, dir.z);
      follower.rotationY += (targetRotation - follower.rotationY) * 0.15;

      follower.mesh.position.copy(follower.position);
      follower.mesh.rotation.y = follower.rotationY;
    }

    // Pickups collision
    for (let i = pickups.length - 1; i >= 0; i--) {
      if (pickups[i].position.distanceTo(player.position) < 3) {
        scene.remove(pickups[i]);
        pickups.splice(i, 1);
        score++;
        scoreEl.textContent = score;
        window.addFollower();
        spawnPickup();
        await trySubmitScore();
      }
    }

    // Obstacles collision
    for(const obs of obstacles){
      if(obs.position.distanceTo(player.position) < 4.5){
        await trySubmitScore();
        showRestartScreen();
      }
    }

    // Boundary check
    if (player.position.length() > ARENA_RADIUS) {
      await trySubmitScore();
      showRestartScreen();
    }

    // Camera follow
    camera.position.lerp(new THREE.Vector3(
      player.position.x - 30 * Math.sin(player.rotationY),
      player.position.y + 20,
      player.position.z - 30 * Math.cos(player.rotationY)
    ), 0.1);
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  // Spawn a pickup anywhere inside arena
  function spawnPickup() {
    const r = THREE.MathUtils.randFloat(10, ARENA_RADIUS - 10);
    const a = THREE.MathUtils.randFloat(0, Math.PI * 2);
    const x = Math.cos(a) * r, z = Math.sin(a) * r;
    const coneGeo = new THREE.ConeGeometry(1.2, 2.2, 10);
    const coneMat = new THREE.MeshStandardMaterial({ color: 0x00ffae });
    const mesh = new THREE.Mesh(coneGeo, coneMat);
    mesh.position.set(x, 1.1, z);
    mesh.rotation.x = Math.PI;
    scene.add(mesh);
    pickups.push(mesh);
  }

  window.addEventListener('resize', () => {
    if(camera && renderer){
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }
  });

  // Start listening to leaderboard even before game starts for instant update
  listenLeaderboard();

})();
</script>
</body>
</html>
